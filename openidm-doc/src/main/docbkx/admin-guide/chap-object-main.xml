<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! legal/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2011 ForgeRock AS
  !    
-->
<chapter xml:id='chap-object-main'
 xmlns='http://docbook.org/ns/docbook'
 version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'
 xmlns:xinclude='http://www.w3.org/2001/XInclude'>
 <title>Data Models &amp; Objects</title>

 <para>OpenIDM allows you to customize of a variety of objects. In REST
 nomenclature, the objects are referred to as <firstterm>resources</firstterm>.
 Resources are objects that can be addressed via a URL or URI, and that have a
 common set of functions that OpenIDM can perform on them such as CRUD, query,
 and action. The term resource in this context should not be confused with
 target resources that you provision to using, for example, an OpenICF
 connector.</para>

 <para>Depending on how you intend to use them, different objects are
 appropriate.</para>

 <table rules="none" frame="topbot" xml:id="table-object-types">
  <title>OpenIDM Objects</title>
  <tgroup cols="3">
   <colspec colnum="1" colwidth="1*"/>
   <colspec colnum="2" colwidth="2*"/>
   <colspec colnum="3" colwidth="1*"/>
   <thead>
    <row>
     <entry>Object Type</entry>
     <entry>Intended Use</entry>
     <entry>Special Functionality</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>Managed objects</entry>
     <entry>Serve as targets and sources for synchronization, and to build
     virtual identities. Managed objects are domain objects to be stored and
     managed by OpenIDM.</entry>
     <entry>Provide appropriate auditing, script hooks, declarative mappings
     and so forth in addition to the REST interface.</entry>
    </row>
    <row>
     <entry>Configuration objects</entry>
     <entry>Ideal for look-up tables or other custom configuration, which
     can be configured externally like any other system configuration.</entry>
     <entry>Adds file view, REST interface, and so forth</entry>
    </row>
    <row>
     <entry>Repository objects</entry>
     <entry>The equivalent of arbitrary database table access. Appropriate
     when it is appropriate to manage data purely through the underlying
     data store or repository API.</entry>
     <entry>Persistence and API access</entry>
    </row>
    <row>
     <entry>System objects</entry>
     <entry>Representation of target resource objects, such as accounts,
     but also resource objects such as groups.</entry>
     <entry>-</entry>
    </row>
    <row>
     <entry>Audit objects</entry>
     <entry>TODO</entry>
     <entry>TODO</entry>
    </row>
    <row>
     <entry>Links</entry>
     <entry>TODO</entry>
     <entry>TODO</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <section xml:id="object-main-resource-API">
  <title>Accessing Objects</title>

  <!-- TODO: Link to the resource API reference elsewhere in the documentation. -->
  <para>OpenIDM's uniform programming model means that all objects are queried
  and manipulated in the same way from your scripts using the Resource API.
  The URL or URI used to identify the target object for an operation depends
  on the object type. Also additional functionality is available for different
  types of object, known as <firstterm>Resource Sets</firstterm>.</para>

  <para>For example, you get managed objects, configuration objects, and
  repository objects in the following way using the Resource API.</para>

  <programlisting language="javascript">
val = openidm.read("managed/organization/mysampleorg")

val = openidm.read("config/custom/mylookuptable")

val = openidm.read("repo/custom/mylookuptable")</programlisting>

  <para>You update entire objects with the <literal>update()</literal>
  function.</para>

  <programlisting language="javascript">
openidm.update("managed/organization/mysampleorg", mymap)

openidm.update("config/custom/mylookuptable", mymap)

openidm.update("repo/custom/mylookuptable", mymap)</programlisting>

  <para>The <literal>create()</literal>, <literal>delete()</literal>, and
  <literal>query()</literal> functions work in similar fashion.</para>

  <para>To get a managed object through the REST API, depending on your
  security settings and authentication configuration, perform an HTTP GET
  on a similar URL, such as
  <literal>https://localhost:8443/openidm/managed/organization/mysampleorg</literal>.</para>

  <para>By default, the HTTP GET returns a JSON representation of the object.
  See the chapter on <link xlink:href="admin-guide#chap-rest"
  xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Using RESTful
  Services</citetitle></link> for details.</para>
 </section>

 <section xml:id="object-main-managed-objects">
  <title>Managed Objects</title>

  <para>Managed objects in OpenIDM are inherently fully user definable and
  customizable. Like all OpenIDM objects, managed objects can maintain
  relationships to each other in the form of links. Managed objects are
  intended for use as targets and sources for synchronization operations to
  represent domain objects, and to build up virtual identities. The name comes
  from the intention that OpenIDM stores and manages these objects, as opposed
  to system objects that are present in external systems.</para>

  <para>OpenIDM can synchronize and map directly between external systems
  (system objects), without storing intermediate managed objects. Managed
  objects are appropriate, however, as a way to cache the data&#8212;for
  example, when mapping to multiple target systems, or when decoupling the
  availability of systems&#8212;to more fully report and audit on all object
  changes during reconciliation, and to build up views that are different from
  the original source, such transformed and combined or virtual views. Managed
  objects can also be allowed to act as an authoritative source if no other
  appropriate source is available.</para>

  <para>Other object types exist for other settings that should be available
  to a script, such as configuration or look-up tables that do not need audit
  logging.</para>

  <section xml:id="object-main-managed-objects-setup">
   <title>Setting Up a Managed Object Type</title>

   <para>To set up a managed object, you declare the object in the
   <filename>conf/managed.json</filename> file where OpenIDM is installed.
   The following example adds a simple <literal>foobar</literal> object
   declaration after the user object type.</para>

   <programlisting language="javascript">{
    "objects": [
        {
            "name": "user"
        },
        {
            "name": "foobar"
        }
    ]
}</programlisting>
  </section>

  <section xml:id="object-main-managed-objects-declarative">
   <title>Manipulating Managed Objects Declaratively</title>

   <para>By mapping an object to another object, either an external system
   object or another internal managed object, you automatically tie the object
   life cycle and property settings to the other object. See the chapter on
   <link xlink:href="admin-guide#chap-synchronization"
   xlink:role="http://docbook.org/xlink/role/olink"
   ><citetitle>Configuring Synchronization</citetitle></link> for
   details.</para>
  </section>

  <section xml:id="object-main-managed-objects-programmatic">
   <title>Manipulating Managed Objects Programmatically</title>

   <para>You can address managed objects as resources using URLs or URIs with
   the <literal>managed/</literal> prefix. This works whether you address the
   managed object internally as a script running in OpenIDM or externally
   through the REST interface.</para>

   <para>You can use all resource API functions in script objects for
   create, read, update, delete operations, and also for arbitrary queries on
   the object set, but not currently for arbitrary actions. See the
   chapter on <link xlink:href="reference#chap-scripting"
   xlink:role="http://docbook.org/xlink/role/olink"
   ><citetitle>Scripting</citetitle></link> in the
   <citetitle>Reference</citetitle> for details.</para>

   <para>OpenIDM supports concurrency through a multi version concurrency
   control (MVCC) mechanism. In other words, each time an object changes,
   OpenIDM assigns it a new revision.</para>

   <para>Objects can be arbitrarily complex as long as they use supported
   types, such as maps, lists, numbers, strings, and booleans as defined in
   <link xlink:href="http://www.json.org" xlink:show="new">JSON</link>.</para>
   
   <section xml:id="object-main-managed-objects-programmatic-create">
    <title>Creating Objects</title>

    <para>The following script example creates an object type.</para>
    <programlisting language="javascript">
openidm.create("managed/foobar/myidentifier", mymap)</programlisting>
   </section>

   <section xml:id="object-main-managed-objects-programmatic-update">
    <title>Updating Objects</title>

    <para>The following script example updates an object type.</para>
    <programlisting language="javascript">var expectedRev = origMap._rev
openidm.update("managed/foobar/myidentifier", expectedRev, mymap)</programlisting>

    <para>The MVCC mechanism requires that <literal>expectedRev</literal>
    be set to the expected revision of the object to update. You obtain the
    revision from the object's <literal>_rev</literal> property. If something
    else changes the object concurrently, OpenIDM rejects the update, and you
    must either retry or inspect the concurrent modification.</para>
   </section>

   <section xml:id="object-main-managed-objects-programmatic-patch">
    <title>Patching Objects</title>

    <para>You can partially update an object using a patch, which changes only
    the specified properties of the object. OpenIDM supports patch by query,
    so the caller need not know the identifier of the object to change.</para>

    <!-- TODO: an example would be nice. -->
   </section>

   <section xml:id="object-main-managed-objects-programmatic-delete">
    <title>Deleting Objects</title>

    <para>The following script example deletes an object type.</para>

    <programlisting language="javascript">var expectedRev = origMap._rev
openidm.delete("managed/foobar/myidentifier", expectedRev)</programlisting>

    <para>The MVCC mechanism requires that <literal>expectedRev</literal>
    be set to the expected revision of the object to update. You obtain the
    revision from the object's <literal>_rev</literal> property. If something
    else changes the object concurrently, OpenIDM rejects deletion, and you
    must either retry or inspect the concurrent modification.</para>
   </section>

   <section xml:id="object-main-managed-objects-programmatic-read">
    <title>Reading Objects</title>

    <para>The following script example reads an object type.</para>

    <programlisting language="javascript">
val = openidm.read("managed/foobar/myidentifier")</programlisting>
   </section>

   <section xml:id="object-main-managed-objects-programmatic-query">
    <title>Querying Object Sets</title>

    <para>The following script example queries object type instances.</para>

    <programlisting language="javascript">
var params = {
    "_query-id": "my-custom-query-id",
    "mycustomtoken": "samplevalue"
};
val = openidm.query("managed/foobar", params);</programlisting>

    <para>The example sets up a query with ID
    <literal>my-custom-query-id</literal>. The query definition (not shown)
    is found in the repository configuration. The query definition includes
    the parameter <literal>mycustomtoken</literal> for token
    substitution.</para>
   </section>
  </section>

  <section xml:id="object-main-managed-objects-access-rest">
   <title>Accessing Managed Objects Through the REST API</title>

   <para>OpenIDM exposes all managed object functionality through the REST API
   unless you configure a policy to prevent such access. In addition to the
   common REST functionality of create, read, update, delete, patch, and query,
   the REST API also supports patch by query.</para>
   <!-- TODO: link to admin-guide#chap-rest or reference#chap-rest ? -->
  </section>
 </section>

 <section xml:id="object-main-configuration-objects">
  <title>Configuration Objects</title>

  <para>OpenIDM provides an extensible configuration to allow you to leverage
  regular configuration mechanisms.</para>

  <para>Unlike native OpenIDM configuration, which OpenIDM interprets
  automatically and can start new services, OpenIDM stores custom configuration
  objects and makes them available to your code through the API.</para>

  <section xml:id="object-main-configuration-objects-when-to-use">
   <title>When To Use Configuration Objects</title>

   <para>Configuration objects are ideal for metadata and settings that need
   not be included in the data to reconcile. In other words, use configuration
   objects for data that does not require and audit log, and does not serve
   directly as a target or source for mappings.</para>

   <para>Although you can set and manipulate configuration objects both
   programmatically and also manually, configuration objects are expected to
   change slowly, perhaps through a mix of both manual file updates and also
   programmatic updates. To store temporary values that can change frequently
   and that you do not expect to be updated by configuration file changes,
   custom repository objects can be more appropriate.</para>
  </section>

  <section xml:id="object-main-configuration-objects-naming">
   <title>Configuration Object Naming Conventions</title>

   <para>By convention custom configuration objects are added under the
   reserved context, <literal>config/custom</literal>.</para>

   <para>You can choose any name under
   <literal>config/<replaceable>context</replaceable></literal>. Be sure,
   however, to choose a value for <replaceable>context</replaceable> that
   does not clash with future OpenIDM configuration names.</para>
  </section>

  <section xml:id="object-main-configuration-objects-file-mapping">
   <title>Mapping Configuration Objects To Configuration Files</title>

   <para>If you have not disabled the file based view for configuration, you
   can view and edit all configuration including custom configuration in
   <filename>conf/*.json</filename> files where you installed OpenIDM. The
   configuration maps to a file named
   <filename><replaceable>context</replaceable>-<replaceable>config-name</replaceable>.json</filename>,
   where <replaceable>context</replaceable> for custom configuration objects
   is <literal>custom</literal> by convention, and
   <replaceable>config-name</replaceable> is the configuration object name.
   A configuration object named <literal>escalation</literal> thus maps to a
   file named <filename>conf/custom-escalation.json</filename>.</para>

   <para>OpenIDM detects and automatically picks up changes to the file.</para>

   <para>OpenIDM also applies changes made through APIs to the file.</para>

   <para>By default, OpenIDM stores configuration objects in the repository.
   The file view is an added convenience aimed to help you in the development
   phase of your project.</para>
  </section>

  <section xml:id="object-main-configuration-objects-formats">
   <title>Configuration Objects File &amp; REST Payload Formats</title>

   <para>By default, OpenIDM maps configuration objects to JSON
   representations.</para>

   <para>OpenIDM represents objects internally in plain, native types like
   maps, lists, strings, numbers, booleans, null. OpenIDM constrains the
   object model to simple types so that mapping objects to external
   representations is trivial.</para>

   <para>The following example shows a representation of a configuration
   object with a look-up map.</para>

   <programlisting language="javascript">{
    "CODE123" : "ALERT",
    "CODE889" : "IGNORE"
}</programlisting>

   <para>In the JSON representation, maps are represented with braces
   (<literal>{ }</literal>), and lists are represented with brackets
   (<literal>[ ]</literal>). Objects can be arbitrarily complex, as in the
   following example.</para>

   <programlisting language="javascript">{
    "CODE123" : {
        "email" : ["sample@sample.com", "john.doe@somedomain.com"],
        "sms" : ["555666777"]
    }
    "CODE889" : "IGNORE"
}</programlisting>
  </section>

  <section xml:id="object-main-configuration-objects-access-rest">
   <title>Accessing Configuration Objects Through the REST API</title>

   <para>You can list all available configuration objects, including system
   and custom configurations, using an HTTP GET on
   <literal>/openidm/config</literal>.</para>

   <para>The <literal>_id</literal> property in the configuration object
   provides the link to the configuration details with an HTTP GET on
   <literal>/openidm/config/<replaceable>id-value</replaceable></literal>.
   By convention, the <replaceable>id-value</replaceable> for a custom
   configuration object called <literal>escalation</literal> is
   <literal>custom/escalation</literal>.</para>

   <para>OpenIDM supports REST mappings for create, read, update, and delete
   of configuration objects. Currently OpenIDM does not support patch and
   custom query operations for configuration objects.</para>
  </section>

  <section xml:id="object-main-configuration-objects-access-programmatic">
   <title>Accessing Configuration Objects Programmatically</title>

   <para>You can address configuration objects as resources using the URL or
   URI <literal>config/</literal> prefix both internally and also through
   the REST interface. The resource API provides script object functions for
   create, read, update, and delete operations.</para>

   <para>OpenIDM supports concurrency through a multi version concurrency
   control mechanism. In other words, each time an object changes, OpenIDM
   assigns it a new revision.</para>

   <para>Objects can be arbitrarily complex as long as they use supported
   types, such as maps, lists, numbers, strings, and booleans.</para>
  </section>

   <section xml:id="object-main-configuration-objects-programmatic-create">
    <title>Creating Objects</title>

    <para>The following script example creates an object type.</para>
    <programlisting language="javascript">
openidm.create("config/custom/myconfig", mymap)</programlisting>
   </section>

   <section xml:id="object-main-configuration-objects-programmatic-update">
    <title>Updating Objects</title>

    <para>The following script example updates an object type.</para>
    <programlisting language="javascript">var expectedRev = origMap._rev
openidm.update("managed/custom/myconfig", expectedRev, mymap)</programlisting>

    <para>The MVCC mechanism requires that <literal>expectedRev</literal>
    be set to the expected revision of the object to update. You obtain the
    revision from the object's <literal>_rev</literal> property. If something
    else changes the object concurrently, OpenIDM rejects the update, and you
    must either retry or inspect the concurrent modification.</para>
   </section>

   <section xml:id="object-main-configuration-objects-programmatic-delete">
    <title>Deleting Objects</title>

    <para>The following script example deletes an object type.</para>

    <programlisting language="javascript">var expectedRev = origMap._rev
openidm.delete("config/custom/myconfig", expectedRev)</programlisting>

    <para>The MVCC mechanism requires that <literal>expectedRev</literal>
    be set to the expected revision of the object to update. You obtain the
    revision from the object's <literal>_rev</literal> property. If something
    else changes the object concurrently, OpenIDM rejects deletion, and you
    must either retry or inspect the concurrent modification.</para>
   </section>

   <section xml:id="object-main-configuration-objects-programmatic-read">
    <title>Reading Objects</title>

    <para>The following script example reads an object type.</para>

    <programlisting language="javascript">
val = openidm.read("config/custom/myconfig")</programlisting>
   </section>
 </section>

 <section xml:id="object-main-system-objects">
  <title>System Objects</title>
  <para><firstterm>System objects</firstterm> are pluggable representations of
  objects on external systems. They follow the same RESTful resource based
  design principles as managed objects. There is a default implementation for
  the OpenICF framework, which allows any connector object to be represented
  as a system object.</para>
 </section>

 <section xml:id="object-main-audit-objects">
  <title>Audit Objects</title>
  <para>TODO</para>
 </section>

 <section xml:id="object-main-links">
  <title>Links</title>
  <para>TODO</para>
 </section>
</chapter>
