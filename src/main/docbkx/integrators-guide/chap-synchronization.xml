<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! legal/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2011-2015 ForgeRock AS
  !    
-->
<chapter xml:id='chap-synchronization'
 xmlns='http://docbook.org/ns/docbook'
 version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook
 http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'>

 <title>Configuring Synchronization</title>
 <indexterm>
  <primary>Synchronization</primary>
 </indexterm>

 <para>
  One of the core services of OpenIDM is synchronizing identity data from
  different resources. This chapter explains what you must know to get started
  configuring OpenIDM's flexible synchronization mechanism, and illustrates the
  concepts with examples.
 </para>

 <section xml:id="sync-types">
  <title>Types of Synchronization</title>
  <indexterm>
   <primary>Synchronization</primary>
   <secondary>Direct (push)</secondary>
  </indexterm>

  <para>
   Synchronization happens either when OpenIDM receives a change directly, or
   when OpenIDM discovers a change on an external resource.
  </para>
  <para>
   For direct changes to managed objects, OpenIDM immediately synchronizes those
   changes to all mappings configured to use those objects as their source.
   A direct change can originate not only as a write request through the REST
   interface, but also as an update resulting from reconciliation with another
   resource.
  </para>

  <variablelist>
   <para>
    OpenIDM discovers and synchronizes changes from external resources by using
    <emphasis>reconciliation</emphasis> and <emphasis>LiveSync</emphasis>.
   </para>
   <para>
    OpenIDM synchronizes changes to its internal repository with external
    resources by using <emphasis>implicit synchronization</emphasis>.
   </para>

   <varlistentry>
    <term>Reconciliation</term>
    <listitem>
     <indexterm>
      <primary>Reconciliation</primary>
     </indexterm>
     <para>
      In identity management, <firstterm>reconciliation</firstterm> is the
      process of bidirectional synchronization of objects between different data
      stores. Traditionally, reconciliation applies mainly to user objects, but
      OpenIDM can reconcile any objects, such as groups, roles, devices, and so
      forth.
     </para>
     <para>
      To perform reconciliation, OpenIDM analyzes both source and target systems
      to uncover the differences that it must reconcile. Reconciliation can
      therefore be a heavyweight process. When working with large data sets,
      finding all changes can be more work than processing the changes.
     </para>
     <para>
      Reconciliation is, however, thorough. It recognizes system error
      conditions and catches changes that might be missed by the more
      lightweight LiveSync mechanism. Reconciliation therefore serves as the
      basis for compliance and reporting functionality.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>LiveSync</term>
    <listitem>
     <indexterm>
      <primary>LiveSync</primary>
     </indexterm>
     <para>
      <firstterm>LiveSync</firstterm> captures the changes that occur on a
      remote system, then pushes those changes to OpenIDM. OpenIDM uses the
      defined mappings to replay the changes where they are required - either in
      the OpenIDM repository, or on another remote system, or both. Unlike
      reconciliation, LiveSync uses a polling system, and is intended to react
      quickly to changes as they happen.
     </para>
     <para>
      To perform this polling, LiveSync relies on a change detection mechanism
      on the external resource to determine which objects have changed. The
      change detection mechanism is specific to the external resource, and can
      be a time stamp, a sequence number, a change vector or any other method of
      recording changes that have occurred on the system. For example, OpenDJ
      implements a change log that provides OpenIDM with a list of objects that
      have changed since the last request. Active Directory implements a change
      sequence number, and certain databases might have a
      <literal>lastChange</literal> attribute.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Implicit synchronization</term>
    <listitem>
     <para>
      <firstterm>Implicit synchronization</firstterm> automatically pushes
      changes that are made in the OpenIDM internal repository to external
      systems.
     </para>
     <para>
      Note that implicit synchronization only pushes <emphasis>changes</emphasis>
      out to the external data sources. To synchronize a complete data set, you
      must start with a reconciliation operation.
     </para>
     <para>
      To disable implicit synchronization, see
      <xref linkend="disabling-automatic-sync" />.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   To determine what to synchronize, and how to carry out synchronization,
   OpenIDM relies on mappings configured in the
   <filename><replaceable>project-dir</replaceable>/conf/sync.json</filename>
   file. LiveSync and implicit sync rely on the mappings configured once per
   OpenIDM server.
  </para>

  <para>
   For reconciliation or LiveSync, you can schedule changes as described in
   <link xlink:show="new" xlink:href="integrators-guide#chap-scheduler-conf"
   xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Scheduling
   Tasks and Events</citetitle></link>.
  </para>

  <para>
   OpenIDM logs reconciliation and synchronization operations in the audit logs
   by default. For information about querying the reconciliation and
   synchronization logs, see <link xlink:show="new" xlink:role="http://docbook.org/xlink/role/olink"
   xlink:href="integrators-guide#querying-audit-over-rest"><citetitle>Querying
   Audit Logs Over REST</citetitle></link>.
  </para>
 </section>

 <section xml:id="sync-flexible-data">
  <title>Flexible Data Model</title>
  <indexterm>
   <primary>Objects</primary>
   <secondary>Managed objects</secondary>
  </indexterm>

  <para>
   Identity management software tends to favor either a meta-directory data
   model, where all data are mirrored in a central repository, or a virtual data
   model, where only a minimum set of attributes are stored centrally, and most
   are loaded on demand from the external resources in which they are stored.
   The meta-directory model offers fast access at the risk of getting outdated
   data. The virtual model guarantees fresh data, but pays for that guarantee in
   terms of performance.
  </para>

  <para>
   OpenIDM leaves the data model choice up to you. You determine the right trade
   offs for a particular deployment. OpenIDM does not hard code any particular
   schema or set of attributes stored in the repository. Instead, you define how
   external system objects map onto managed objects, and OpenIDM dynamically
   updates the repository to store the managed object attributes that you
   configure.
  </para>

  <para>
   You can, for example, choose to follow the data model defined in the Simple
   Cloud Identity Management (<link xlink:show="new"
   xlink:href="http://www.simplecloud.info/specs/draft-scim-core-schema-00.html"
   >SCIM</link>) specification. The following object represents a SCIM user.
  </para>

  <programlisting language="javascript">
{
    "userName": "james1",
    "familyName": "Berg",
    "givenName": "James",
    "email": [
        "james1@example.com"
    ],
    "description": "Created by OpenIDM REST.",
    "password": "asdfkj23",
    "displayName": "James Berg",
    "phoneNumber": "12345",
    "employeeNumber": "12345",
    "userType": "Contractor",
    "title": "Vice President",
    "active": true
}</programlisting>

  <note>
   <para>
    Avoid using the dash character ( <literal>-</literal> ) in property names,
    like <literal>last-name</literal>, as dashes in names make JavaScript syntax
    more complex. If you cannot avoid the dash, then write
    <literal>source['last-name']</literal> instead of
    <literal>source.last-name</literal> in your JavaScript.
   </para>
  </note>
 </section>

 <section xml:id="basic-sync">
  <title>Configuring Basic Synchronization</title>
  <para>
   A basic synchronization configuration between two resources involves the
   following steps:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Set up the connector configuration.
    </para>
    <para>
     The connector configuration is defined in the file
     <filename>conf/provisioner-*.json</filename>. One provisioner file exists
     for each external resource to which you are connecting.
    </para>
   </listitem>
   <listitem>
    <para>
     Configure a synchronization mapping.
    </para>
    <para>
     Mappings are defined in the file <filename>conf/sync.json</filename>. There
     is only one <filename>sync.json</filename> file per OpenIDM instance, but
     multiple mappings can be defined in that file.
    </para>
   </listitem>
   <listitem>
    <para>
     Configure any scripts that are required to check source and target objects,
     and to manipulate attributes.
    </para>
   </listitem>
   <listitem>
    <para>
     In addition to these configuration elements, OpenIDM stores a
     <literal>links</literal> table, in its repository. The links table
     maintains a record of relationships established between source and target
     objects.
    </para>
   </listitem>
  </itemizedlist>

  <section xml:id="connector-config-files">
   <title>Setting up the Connector Configuration</title>
   <indexterm>
    <primary>Synchronization</primary>
    <secondary>Connectors</secondary>
   </indexterm>
   <para>
    Connector configuration files map external resource objects to OpenIDM
    objects, and are described in detail in the chapter on <link
    xlink:href="integrators-guide#chap-resource-conf"
    xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Connecting to
    External Resources</citetitle></link>. Connector configuration files are
    stored in the <literal>conf/</literal> directory of your project, and are
    named <filename>provisioner.<replaceable>resource-name</replaceable>.json</filename>,
    where <replaceable>resource-name</replaceable> reflects the connector
    technology and the external resource, for example,
    <literal>openicf-xml</literal>.
   </para>

   <para>
    You can modify the connector configuration through the Admin UI or
    directly in the configuration file, as described in the following sections.
   </para>

   <section xml:id="connector-config-adminui">
    <title>Setting up the Connector Configuration in the Admin UI</title>

    <para>
     To review the corresponding information in the Admin UI, navigate to
     <literal>https://localhost:8443/admin</literal>, and log in as an
     administrative user. The default administrative username and password is
     <literal>openidm-admin</literal> and <literal>openidm-admin</literal>.
    </para>

    <para>
     Navigate to Configure &gt; Connectors, and select the connector associated
     with the desired external resource. Select the object type such as
     <literal>account</literal>, and select the edit icon.
    </para>

    <para>
     You should see a window where you can select all applicable object type
     properties such as <literal>lastName</literal> and
     <literal>homePhone</literal>.
    </para>

   </section>

   <section xml:id="connector-config-files-cli">
    <title>Editing Connector Configuration Files</title>

    <para>
     To help you modify connector configuration files, look at the following
     example, which shows the name for the connector and two attributes of an
     account object type. In the attribute mapping definitions, the attribute
     name is mapped from the <literal>nativeName</literal> (the attribute
     name used on the external resource) to the attribute name that is used
     in OpenIDM. The example shows that the <literal>sn</literal> attribute
     in LDAP is mapped to <literal>lastName</literal> in OpenIDM.
     The <literal>homePhone</literal> attribute is defined as an array,
     because it can have multiple values.
    </para>

    <programlisting language="javascript">
{
    "name": "MyLDAP",
    "objectTypes": {
        "account": {
            "lastName": {
                "type": "string",
                "required": true,
                "nativeName": "sn",
                "nativeType": "string"
            },
            "homePhone": {
                "type": "array",
                "items": {
                    "type": "string",
                    "nativeType": "string"
                },
                "nativeName": "homePhone",
                "nativeType": "string"
            }
        }
    }
}</programlisting>

    <para>
     For OpenIDM to access external resource objects and attributes, the object
     and its attributes must match the connector configuration. Note that the
     connector file only maps external resource objects to OpenIDM objects. To
     construct attributes and to manipulate their values, you use the
     synchronization mappings file, described in the following section.
    </para>

   </section>
  </section>

  <section xml:id="synchronization-mappings-file">
   <title>Configuring the Synchronization Mapping</title>
    <indexterm>
     <primary>Synchronization</primary>
     <secondary>Mappings</secondary>
    </indexterm>
    <indexterm>
     <primary>Mappings</primary>
    </indexterm>
    <para>
     A synchronization mapping specifies a relationship between properties in
     two data stores. One typical mapping between an external LDAP directory
     and an internal Managed User data store is:
    </para>
    <screen>"source": "lastName",
"target": "sn"</screen>
    <para>
     In this case, the <literal>lastName</literal> source attribute is mapped
     to the <literal>sn</literal> (surname) attribute on the target.
    </para>

    <para>
     The synchronization mappings file (<filename>conf/sync.json</filename>)
     represents the core configuration for OpenIDM synchronization.
    </para>
    <para>
     The <filename>sync.json</filename> file defines attribute mappings from a
     source to a target. You can assign a data store as a source and a target.
     So if you want to configure two-way synchronization, you must define a
     separate mapping for each data flow. For example, if you want data to flow
     from an LDAP server to the repository and also from the repository to the
     LDAP server, you would define two separate mappings.
    </para>

    <para>
     You can also identify and add mappings in the Admin UI. To do so,
     navigate to <literal>https://localhost:8443/admin</literal>, and click
     Configure &gt; Mappings.
    </para>

    <para>
     You can update mappings in the <filename>sync.json</filename> file or
     the Admin UI while the server is running, as long as you do not update a
     mapping that is currently being used by a reconciliation process.
    </para>

    <para>
     In the Admin UI, you can also configure mappings for individual attributes.
     Click on a specific mapping &gt; Properties. In the Attributes Grid,
     select a property.
    </para>

    <mediaobject>
     <alt>Admin UI - Property Mapping</alt>
     <imageobject>
      <imagedata fileref="images/admin-ui-map-properties.png" format="PNG" />
     </imageobject>
    </mediaobject>

    <para>
     The Admin UI serves as a front-end to OpenIDM configuration files. The
     changes you make to resource and attribute mappings are written to the
     <filename>sync.json</filename> file as described in the following
     sections:
    </para>

    <section xml:id="mapping-resources-text">
     <title>Identifying Resource Mappings in <literal>sync.json</literal></title>
     <para>
      External resources are shown in a mapping as
      <literal>system/<replaceable>name</replaceable>/<replaceable>object-type</replaceable></literal>,
      where <replaceable>name</replaceable> is the name used in the connector
      configuration file, and <replaceable>object-type</replaceable> is the
      object defined in the connector configuration file list of object types.
      In contrast, objects in OpenIDM's internal repository are specified in the mapping as
      <literal>managed/<replaceable>object-type</replaceable></literal>, where
      <replaceable>object-type</replaceable> is defined in the managed objects
      configuration file (<filename>conf/managed.json</filename>).
     </para>
     <para>
      External resources, and OpenIDM managed objects, can be the
      <emphasis>source</emphasis> or the <emphasis>target</emphasis> in a
      mapping. The mapping name, by convention, is set to a string of the form
      <literal><replaceable>source</replaceable>_<replaceable>target</replaceable></literal>,
      as shown in the following example.
     </para>
     <programlisting language="javascript" xml:id="basic-ldap-mapping">
{
    "mappings": [
        {
            "name": "systemLdapAccounts_managedUser",
            "source": "system/ldap/account",
            "target": "managed/user",
            "properties": [
                {
                    "source": "lastName",
                    "target": "sn"
                },
                {
                    "source": "telephoneNumber",
                    "target": "telephoneNumber"
                },
                {
                    "target": "phoneExtension",
                    "default": "0047"
                },
                {
                    "source": "email",
                    "target": "mail",
                    "comment": "Set mail if non-empty.",
                    "condition": {
                        "type": "text/javascript",
                        "source": "(object.email != null)"
                    }
                },
                {
                    "source": "",
                    "target": "displayName",
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.lastName +', ' + source.firstName;"
                    }
                },
               {
                    "source" : "uid",
                    "target" : "userName",
                    "condition" : "/linkQualifier eq \"user\""
                    }
               },
            ]
        }
    ]
}    </programlisting>
     <para>
      In this example, the source is the external resource
      (<literal>ldap</literal>), and the target is OpenIDM's repository,
      specifically the managed user objects. The <literal>properties</literal>
      defined in the mapping reflect attribute names that are defined in the
      OpenIDM configuration. For example, the source attribute
      <literal>uid</literal> is defined in the <literal>ldap</literal>
      connector configuration file, rather than on the external resource itself.
     </para>
     <para>
      To add a flow from the repository to the <literal>ldap</literal> resource,
      you would define a mapping with source <literal>managed/user</literal> and
      target <literal>system/ldap/account</literal>. In this case, the name for
      the mapping would be <literal>managedUser_systemLdapAccounts</literal>.
     </para>

    </section>

    <section xml:id="mapping-creating-attributes">
     <title>Creating Attributes in a Mapping</title>
     <indexterm>
      <primary>Synchronization</primary>
      <secondary>Creating attributes</secondary>
     </indexterm>
     <para>
      You can create attributes on the target as part of the mapping. In the
      preceding example, a <literal>phoneExtension</literal> attribute with a
      default value of <literal>0047</literal> is created on the target.
     </para>
     <para>
      You can also use the <literal>"default"</literal> property to specify a
      value to assign to the target property. When OpenIDM determines the value
      of the target property, any associated conditions are evaluated first,
      followed by the transform script, if present. The default value is applied
      (for update and create actions) if the <literal>"source"</literal>
      property and the <literal>"transform"</literal> script yield a null value.
      The default value overrides the target value, if one exists.
     </para>

     <para>
      To set up these attributes in the Admin UI, log into
      <literal>https://localhost:8443/admin</literal>. Select Configure &gt;
      Mappings, and select the Mapping. In this case, select the
      <literal>phoneExtension</literal> attribute, and enter the desired
      <literal>"default"</literal> property.
     </para>
    </section>

    <section xml:id="mapping-transforming-attributes">
     <title>Transforming Attributes in a Mapping</title>
     <indexterm>
      <primary>Synchronization</primary>
      <secondary>Transforming attributes</secondary>
     </indexterm>
     <para>
      You can use a mapping configuration to define attribute transformations
      that occur during synchronization. In the following excerpt of the sample
      mapping, the value of the <literal>displayName</literal> attribute (on the
      target) is set using a combination of the <literal>lastName</literal> and
      <literal>firstName</literal> attribute values from the source.
     </para>
     <programlisting language="javascript">
{
    "source": "",
    "target": "displayName",
    "transform": {
        "type": "text/javascript",
        "source": "source.lastName +', ' + source.firstName;"
    }
},
     </programlisting>
     <para>
      For transformations, the <literal>source</literal> property is optional.
      However, the source object is only available when you specify the
      <literal>source</literal> property. Therefore, in order to use
      <literal>source.lastName</literal> and <literal>source.firstName</literal>
      to calculate the <literal>displayName</literal>, the example specifies
      <literal>"source" : ""</literal>.
     </para>

     <para>
      To set up this transformation in the Admin UI, log into
      <literal>https://localhost:8443/admin</literal>. Select Configure &gt;
      Mappings, and select the Mapping. In this case, select the line with
      the <literal>displayName</literal> target attribute, and select
      Transformation Script from the window that appears. You can then enter
      <literal>Javascript</literal> for the transformation type, and the
      noted source as an <literal>Inline Script</literal>.
     </para>

    </section>

    <section xml:id="mapping-link-qualifiers">
     <title>Using Link Qualifiers in a Mapping</title>
     <para>
      When you have multiple target objects that map to a single source object,
      you should identify the <emphasis>type</emphasis> of relationship, or link,
      with a <emphasis>link qualifier</emphasis>. For
      example, assume that you have one managed user, <literal>scarter</literal>,
      with two distinct accounts in an LDAP directory: a regular user account
      (<literal>scarter</literal>) and a test account
      (<literal>scarter-test</literal>). In that case, you can use a
      link qualifier to link both of these LDAP accounts to the single managed
      user object, <literal>scarter</literal>.
     </para>
     <!-- TODO: address multiple source object situation -->
     <para>
      OpenIDM uses link qualifiers in the <filename>sync.json</filename> file
      to differentiate multiple target objects -- that all relate to the same
      source object.
     </para>
     <para>
      A link qualifier can be static or scripted (dynamic). That link qualifier
      can be used in the evaluation of different parts of the mapping, including:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        A transformation script for one or more properties.
       </para>
      </listitem>
      <listitem>
       <para>
        The condition logic for one or more properties.
       </para>
      </listitem>
      <listitem>
       <para>
        A correlation query between source and target.
       </para>
      </listitem>
      <listitem>
       <para>
        A situational analysis.
       </para>
      </listitem>
      <listitem>
       <para>
        Policies that are executed.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      The sum total of these configurations are used to define how records
      associated with one link qualifier differ from another.
     </para>

     <note>
      <para>
       Where possible, do use dynamic <emphasis>link qualifiers</emphasis>. When
       OpenIDM uses a static list of <emphasis>link qualifiers</emphasis>, it
       has to search through each item in the list before synchronizing each
       entry, which can affect the performance of your system.
      </para>
     </note>

     <para>
      Each <literal>linkQualifier</literal> within a specific mapping must be
      unique. If no link qualifier is specified (such as when only one possible
      correlating target object exists) OpenIDM uses a default link qualifier,
      with the value <literal>"default"</literal>.
     </para>

     <para>
      To set up <literal>linkQualifier</literal> conditions in the Admin UI,
      navigate to <literal>https://localhost:8443/admin</literal> and click
      Configure &gt; Mappings. Select a mapping, and click Properties &gt;
      Link Qualifiers.
     </para>
    </section>

    <section xml:id="mapping-conditions">
     <title>Using Conditions in a Mapping</title>
     <indexterm>
      <primary>Synchronization</primary>
      <secondary>Conditions</secondary>
     </indexterm>
     <para>
      By default, OpenIDM synchronizes all attributes in a mapping. To
      facilitate more complex relationships between source and target objects,
      you can define specific conditions under which OpenIDM maps certain
      attributes. OpenIDM supports two types of mapping conditions:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <emphasis>Scriptable conditions</emphasis>, in which an attribute is
        mapped only if the defined script evaluates to <literal>true</literal>
       </para>
      </listitem>
      <listitem>
       <para>
        <emphasis>Link qualifier conditions</emphasis>, used to distinguish the
        properties that are to be set <emphasis>only</emphasis> for the
        identified link qualifier. For more information, see
        <xref linkend="mapping-link-qualifiers" />.
       </para>
      </listitem>
     </itemizedlist>

     <para>
      You can set up these mapping conditions in the Admin UI. To do so,
      log into <literal>https://localhost:8443/admin</literal> and
      Select Properties &gt; the attribute that you want to map,
      and select Conditional Updates from the window that appears.
     </para>

     <para>
      You can then enter Link Qualifier information as a
      <literal>Condition Filter</literal>. Alternatively, you can enter a
      scriptable condition as a <literal>Script</literal>.
     </para>

     <section xml:id="mapping-scriptable-conditions">
      <title>Using Scriptable Conditions</title>
      <para>
       Scriptable conditions enable you to create mapping logic based on a
       defined condition. If the condition script does not return
       <literal>true</literal>, OpenIDM does not manipulate the target attribute
       during a synchronization operation.
      </para>
      <para>
       In the following excerpt of the sample mapping, the value of the target
       <literal>mail</literal> attribute is set to the value of the source
       <literal>email</literal> attribute, <emphasis>only if</emphasis> the
       source attribute is not empty.
      </para>
      <programlisting language="javascript">
{
    "target": "mail",
    "comment": "Set mail if non-empty.",
    "source": "email",
    "condition": {
        "type": "text/javascript",
        "source": "(object.email != null)"
    }
...   </programlisting>
      <para>
       Only the source object is in the condition script's scope, so the
       <literal>object.email</literal> in this example refers to the
       <literal>email</literal> property of the source object.
      </para>
      <note>
      <para>
       You can add comments to your mapping file to indicate how the attributes
       are mapped. This example includes a <literal>"comment"</literal> property
       but you can use any property whose name is meaningful to you, as long as
       that property name is not used elsewhere in the server. OpenIDM simply
       ignores unknown property names in JSON configuration files.
      </para>
      </note>
     </section>

     <section xml:id="link-qualifier-conditions">
      <title>Using Link Qualifier Conditions</title>
      <para>
       In addition to these scriptable conditions, you can define specific
       circumstances in which objects should be linked, by declaring a
       <emphasis>link qualifier</emphasis>, based on individual attributes.
      </para>
      <para>
       In the following excerpt of a sample mapping, two link qualifiers
       (<literal>user</literal> and <literal>test</literal>) are declared for
       the managed user to LDAP mapping. This example assumes two accounts in
       the LDAP directory, a real <literal>user</literal> account and a second,
       <literal>test</literal> account. Both LDAP accounts should be mapped to
       the same managed object.
      </para>
      <programlisting language="javascript">
{
    "mappings": [
        {
            "name": "managedUser_systemLdapAccounts",
            "source": "managed/user",
            "target": "system/MyLDAP/account",
            "linkQualifiers" : [ "user", "test" ],
...   </programlisting>
      <para>
       If you have alternative sets of link qualifiers for different source
       records, you could set up a <filename>linkQualifiers.js</filename>
       script. That script should return an array of strings. If you need a
       link qualifiers script, the noted <filename>sync.json</filename> excerpt
       might look like the following:
      </para>
      <programlisting language="javascript">
{
    "mappings": [
        {
            "name": "managedUser_systemLdapAccounts",
            "source": "managed/user",
            "target": "system/MyLDAP/account",
            "linkQualifiers" : {
                "type" : "text/javascript",
                "file" : "script/linkQualifiers.js"
            }
... </programlisting>
      <para>
       The <literal>linkQualifiers</literal> script can use the following
       variables:
      </para>
      <variablelist>
       <varlistentry>
        <term><literal>mapping</literal></term>
        <listitem>
         <para>
          The name of the current mapping, as defined in
          <filename>sync.json</filename>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>object</literal></term>
        <listitem>
         <para>
          The value of the source object. If the source object does not exist,
          the value is null. For more information, see
          <xref linkend="link-qualifier-object" />.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>oldValue</literal></term>
        <listitem>
         <para>
          The former value of the source object, if any. If the source object is
          new, <literal>oldValue</literal> will be null. When there are deleted
          objects, <literal>oldValue</literal> will be populated only if the
          source is <emphasis>managed</emphasis>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>returnAll</literal></term>
        <listitem>
         <para>
          A boolean option. If set to true, the script must return all known
          link qualifiers.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      <para>
       A <filename>linkQualifiers.js</filename> script
      </para>
      <para>
       Link qualifier conditions can be used to specify when a target attribute
       should be set. The following example sets a default value for the
       <literal>description</literal> attribute on a target object, only if
       the link qualifier to that target object is <literal>test</literal>.
      </para>
      <programlisting language="javascript">
{
    "target" : "description",
    "default": "This is a test account",
    "condition" : "/linkQualifier" eq \"test\""
    }
      </programlisting>
      <para>
       Link qualifiers can be used in conjunction with a transformation script,
       to determine how to set or change a target attribute value. The following
       excerpt of a sample mapping defines a transformation script that
       generates the value of the <literal>dn</literal> attribute on the target
       objects.
      </para>
      <para>
       If the link qualifier is <literal>user</literal>, the value of the target
       <literal>dn</literal> is set to
       <literal>"uid=userName,ou=People,dc=example,dc=com"</literal>. Otherwise,
       we assume that the link qualifier is <literal>test</literal>, and the
       value of the target <literal>dn</literal> is set to
       <literal>"uid=userName-test,ou=People,dc=example,dc=com"</literal>.
      </para>
      <informalexample><?dbfo pgwide="1"?>
      <programlisting language="javascript">{
    "source": "",
    "target": "dn",
    "transform": {
        "type": "text/javascript",
        "source": "if (linkQualifier === 'user') { 'uid=' + source.userName + ',ou=People,dc=example,dc=com'; } else { 'uid=' + source.userName + '-test,ou=People,dc=example,dc=com'; }"
    }
      </programlisting></informalexample>
      <para>
       A link qualifier can also be used in a correlation query or a correlation
       script, to determine existing target objects to associate with the source
       object. For more information about using link qualifiers in correlation
       queries or scripts, see <xref linkend="correlating-multiple-targets" />.
      </para>
     </section>
    </section>

    <section xml:id="link-qualifier-object">
     <title>Conditions related to the Object Variable</title>

     <itemizedlist>
      <listitem>
       <para>
        You can expect that the value of the <emphasis>object</emphasis> variable
        provided in the <literal>linkQualifiers</literal> script is null,
        during a sync or a LiveSync delete event.
       </para>
       <para>
        If your source system is an OpenIDM managed object, you can still get
        all details about the deleted object through its
        <literal>oldValue</literal>.
       </para>
       <para>
        If your source system is external, you will not have access to the
        <literal>oldValue</literal>. In that case, you can mimic the behavior of
        the <literal>returnAll</literal> variable, and return all known link
        qualifiers.
       </para>
      </listitem>
      <listitem>
       <para>
        You can create a <literal>linkQualifiers</literal> script to first
        check for the value of <literal>returnAll</literal>.
       </para>
       <para>
        If the value is <emphasis>true</emphasis>, make sure that the script does
        not attempt to use the <literal>object</literal> variable, as it will be
        null.
       </para>
      </listitem>
     </itemizedlist>

    </section>

    <section xml:id="filtering-source-and-target">
     <title>Filtering the Objects that are Synchronized</title>
     <variablelist>
      <indexterm>
       <primary>Synchronization</primary>
       <secondary>Filtering</secondary>
      </indexterm>
      <para>
       By default, OpenIDM synchronizes all objects that match those defined in
       the connector configuration for the resource. Many connectors allow you
       to limit the scope of objects that the connector accesses. For example,
       the LDAP connector allows you to specify base DNs and LDAP filters so
       that you do not need to access every entry in the directory. OpenIDM also
       enables you to filter the source or target objects that are included in a
       synchronization operation. To apply these filters, use the
       <literal>validSource</literal>, <literal>validTarget</literal>, or
       <literal>sourceCondition</literal> properties in your mapping.
      </para>
      <varlistentry>
       <term>validSource</term>
       <listitem>
        <para>
         A script that determines if a source object is valid to be mapped. The
         script yields a boolean value: <literal>true</literal> indicates that
         the source object is valid; <literal>false</literal> can be used to
         defer mapping until some condition is met. In the root scope, the
         source object is provided in the <literal>"source"</literal> property.
         If the script is not specified, then all source objects are considered
         valid.
        </para>
        <programlisting language="javascript">
{
    "validSource": {
        "type": "text/javascript",
        "source": "source.ldapPassword != null"
    }
}
</programlisting>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>validTarget</term>
       <listitem>
        <para>
         A script, used during reconciliation's second phase, that determines if
         a target object is valid to be mapped. The script yields a boolean
         value: <literal>true</literal> indicates that the target object is
         valid; <literal>false</literal> indicates that the target object should
         not be included in reconciliation. In the root scope, the source object
         is provided in the <literal>"target"</literal> property. If the script
         is not specified, then all target objects are considered valid for
         mapping.
        </para>
        <programlisting language="javascript">{
    "validTarget": {
        "type": "text/javascript",
        "source": "target.employeeType == 'internal'"
    }
}
</programlisting>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sourceCondition</term>
       <listitem>
        <para>
         The <literal>sourceCondition</literal> element enables you to define an
         additional set of key-value conditions that must be met in order for a
         source object to be included in a mapping.
        </para>
        <para>
         This condition is declarative, but functions in the same way as a
         <literal>validSource</literal> script. <literal>sourceCondition</literal>
         is used principally to specify that a mapping applies only to a
         particular role or entitlement.
        </para>
        <para>
         For example, the following <literal>sourceCondition</literal> restricts
         synchronization to those user objects that have the
         <literal>"ldap"</literal> assignment as an effective assignment.
        </para>
        <programlisting language="javascript">{
    "mappings": [
        {
            "name": "managedUser_systemLdapAccounts",
            "source": "managed/user",
            "sourceCondition": {
                "effectiveAssignments": "ldap"
            },
        ...
        }
    ]
}</programlisting>
        <para>
         You can, however, define a declarative
         <literal>sourceCondition</literal> outside of the entitlements context
         to restrict the source objects that are candidates for synchronization.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      During synchronization, your scripts always have access to a
      <literal>source</literal> object and a <literal>target</literal> object.
      Examples already shown in this section use <literal>source.<replaceable
      >attributeName</replaceable></literal> to retrieve attributes from the
      source objects. Your scripts can also write to target attributes using
      <literal>target.<replaceable>attributeName</replaceable></literal> syntax,
      as shown in the following example.
     </para>
     <programlisting language="javascript">
{
    "onUpdate": {
        "type": "text/javascript",
        "source": "if (source.email != null) {target.mail = source.email;}"
    }
}</programlisting>

     <para>
      See the <link xlink:href="integrators-guide#appendix-scripting"
      xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Scripting
      Reference</citetitle></link> appendix for more on scripting.
     </para>
   </section>

  <section xml:id="preventing-accidental-deletion">
   <title>Preventing Accidental Deletion of a Target System</title>
   <para>
    If a source resource is empty, the default behavior is for a reconciliation
    operation to exit, without failure, and to log a warning, similar to the
    following:
   </para>
   <screen>
2015-06-05 10:41:18:918 WARN Cannot reconcile from an empty data source, unless
    allowEmptySourceSet is true.
   </screen>
   <para>
    The reconciliation summary is also logged in the reconciliation audit log.
   </para>
   <para>
    This behavior prevents reconciliation operations from accidentally deleting
    everything in a target resource. For example, in the event that a source
    system is unavailable but erroneously reporting its status as "up", the
    absence of source objects should not result in objects being removed on the
    target resource.
   </para>
   <para>
    There might be situations in which you do want reconciliations of an empty
    source resource to proceed. In this case, you can override the default
    behavior by setting the <literal>"allowEmptySourceSet"</literal> property to
    <literal>true</literal> in the mapping. For example:
   </para>
   <programlisting>
{
    "mappings" : [
        {
        "name" : "systemXmlfileAccounts_managedUser",
        "source" : "system/xmlfile/account",
        "allowEmptySourceSet" : true,
        ...
   </programlisting>
   <para>
    Reconciliation of an empty source effectively wipes out the target.
   </para>
  </section>
  </section>

  <section xml:id="constructing-attributes">
   <title>Constructing and Manipulating Attributes</title>
   <indexterm>
    <primary>Synchronization</primary>
    <secondary>Creating attributes</secondary>
   </indexterm>
   <para>
    OpenIDM provides a number of <emphasis>hooks</emphasis> that enable you to
    construct and manipulate attributes using scripts. These scripts can be
    triggered during various stages of the synchronization process, and are
    defined as part of the mapping, in the <filename>sync.json</filename> file.
   </para>
   <para>
    The scripts can be triggered when a managed or system object is created
    (onCreate), updated (onUpdate), or deleted (onDelete). Scripts can also be
    triggered when a link is created (onLink) or removed (onUnlink).
   </para>
   <para>
    In the default synchronization mapping, changes are
    <emphasis>always</emphasis> written to target objects, not to source
    objects. However, you can explicitly include a call to an action that should
    be taken on the source object within the script.
   </para>
   <note>
    <para>
     The <literal>onUpdate</literal> script is <emphasis>always</emphasis>
     called for an UPDATE situation, even if the synchronization process
     determines that there is no difference between the source and target
     objects, and that the target object will not, in fact, be updated.
    </para>
    <para>
     If, subsequent to the <literal>onUpdate</literal> script running, the
     synchronization process determines that the target value to set is the same
     as its existing value, the change is prevented from being synchronized to
     the target.
    </para>
   </note>
   <para>
    The following sample extract of a <literal>sync.json</literal> file derives
    a DN for an LDAP entry when the entry is created in the internal repository.
   </para>
   <programlisting language="javascript">{
    "onCreate": {
        "type": "text/javascript",
        "source":
            "target.dn = 'uid=' + source.uid + ',ou=people,dc=example,dc=com'"
    }
}</programlisting>
  </section>

  <section xml:id="reusing-links">
   <title>Reusing Links</title>
   <indexterm>
    <primary>Synchronization</primary>
    <secondary>Reusing links</secondary>
   </indexterm>
   <para>
    When two mappings exist to synchronize the same objects bidirectionally, you
    can use the <literal>links</literal> property in one mapping to have OpenIDM
    use the same internally managed link for both mappings. Otherwise, if no
    <literal>links</literal> property is specified, OpenIDM maintains a link for
    each mapping.
   </para>
   <para>
    The following excerpt shows two mappings, one from MyLDAP accounts to
    managed users, and another from managed users to MyLDAP accounts. In the
    second mapping, the <literal>link</literal> property tells OpenIDM to reuse
    the links created in the first mapping, rather than create new links.
   </para>
   <programlisting language="javascript">
{
    "mappings": [
        {
            "name": "systemMyLDAPAccounts_managedUser",
            "source": "system/MyLDAP/account",
            "target": "managed/user"
        },
        {
            "name": "managedUser_systemMyLDAPAccounts",
            "source": "managed/user",
            "target": "system/MyLDAP/account",
            "links": "systemMyLDAPAccounts_managedUser"
        }
    ]
}</programlisting>
   </section>
 </section>

 <section xml:id="recon-over-rest">
  <title>Managing Reconciliation Over REST</title>
  <para>
   You can trigger, cancel, and monitor reconciliation operations over REST,
   using the REST endpoint
   <literal>https://localhost:8443/openidm/recon</literal>.
  </para>

  <section xml:id="triggering-recons">
   <title>Triggering a Reconciliation Run</title>
   <para>
    The following example triggers a reconciliation operation based on the
    <literal>systemLdapAccounts_managedUser</literal> mapping. The mapping is
    defined in the file <filename>conf/sync.json</filename>.
   </para>

   <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=systemLdapAccounts_managedUser"</screen>

   <para>
    By default, an assigned reconciliation run ID is returned immediately when
    the reconciliation operation is initiated. Clients can make subsequent calls
    to the reconciliation service, using this reconciliation run ID to query its
    state and to call operations on it.
   </para>

   <para>
    For example, the reconciliation run initiated previously would return
    something similar to the following:
   </para>

   <screen>{"_id":"0890ad62-4738-4a3f-8b8e-f3c83bbf212e","state":"ACTIVE"}</screen>

   <para>
    To have the entire reconciliation run complete before the reconciliation
    run ID is returned, set the <literal>waitForCompletion</literal> property to
    <literal>true</literal> when the reconciliation is initiated. For example:
   </para>

   <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=systemLdapAccounts_managedUser&amp;waitForCompletion=true"
   </screen>
  </section>

   <section xml:id="recon-details">
    <title>Obtaining the Details of a Reconciliation Run</title>

    <para>
     You can display the details of a particular reconciliation run over REST by
     specifying the reconciliation run ID in the URL. For example, the following
     call shows the details of the reconciliation run initiated in the previous
     section:
    </para>

    <screen>$ <userinput>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/recon/0890ad62-4738-4a3f-8b8e-f3c83bbf212e"</userinput>
     <computeroutput>{
  "ended": "2014-03-06T07:00:32.094Z",
  "_id": "7a07c100-4f11-4d7e-bf8e-fa4594f99d58",
  "mapping": "systemLdapAccounts_managedUser",
  "state": "SUCCESS",
  "stage": "COMPLETED_SUCCESS",
  "stageDescription": "reconciliation completed.",
  "progress": {
     "links": {
       "created": 0,
       "existing": {
         "total": "1",
         "processed": 1
       }
     },
     "target": {
       "created": 0,
       "existing": {
         "total": "3",
         "processed": 3
       }
     },
     "source": {
       "existing": {
         "total": "1",
         "processed": 1
       }
     }
  },
  "situationSummary": {
     "UNASSIGNED": 2,
     "TARGET_IGNORED": 0,
     "SOURCE_IGNORED": 0,
     "MISSING": 0,
     "FOUND": 0,
     "AMBIGUOUS": 0,
     "UNQUALIFIED": 0,
     "CONFIRMED": 1,
     "SOURCE_MISSING": 0,
     "ABSENT": 0
  },
  "started": "2014-03-06T07:00:31.907Z"</computeroutput>
}</screen>
   </section>

   <section xml:id="canceling-recons">
    <title>Canceling a Reconciliation Run</title>

    <para>
     You can cancel a reconciliation run by sending a REST call with the
     <literal>cancel</literal> action, specifying the reconciliation run ID. For
     example, the following call cancels the reconciliation run initiated in the
     previous section:
    </para>

    <screen><?dbfo pgwide="1"?>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon/0890ad62-4738-4a3f-8b8e-f3c83bbf212e?_action=cancel"</screen>

    <para>
     The output for a reconciliation cancellation request is similar to the
     following:
    </para>

    <screen>{
     "status":"SUCCESS",
     "action":"cancel",
     "_id":"0890ad62-4738-4a3f-8b8e-f3c83bbf212e"
}</screen>

    <para>
     If you specified that the call should wait for completion before the ID is
     returned, you can obtain the reconciliation run ID from the list of active
     reconciliations, as described in the following section.
    </para>
   </section>

   <section xml:id="listing-recons">
    <title>Listing Reconciliation Runs</title>

    <para>
     You can display a list of reconciliation processes that have completed, and
     those that are in progress, by running a RESTful GET on
     <literal>"https://localhost:8443/openidm/recon"</literal>. The following
     example displays all reconciliation runs.
    </para>

    <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/recon"
    </screen>

    <para>
     The output of such a request is similar to the following, with one item for
     each reconciliation run.
    </para>

    <screen>{
   "reconciliations": [
     {
       "ended": "2014-03-06T06:14:11.845Z",
       "_id": "4286510e-986a-4521-bfa4-8cd1e039a7f5",
       "mapping": "systemLdapAccounts_managedUser",
       "state": "SUCCESS",
       "stage": "COMPLETED_SUCCESS",
       "stageDescription": "reconciliation completed.",
       "progress": {
         "links": {
           "created": 1,
           "existing": {
           "total": "0",
           "processed": 0
         }
       },
       "target": {
         "created": 1,
         "existing": {
           "total": "2",
           "processed": 2
         }
       },
       "source": {
         "existing": {
           "total": "1",
           "processed": 1
         }
       }
     },
     "situationSummary": {
       "UNASSIGNED": 2,
       "TARGET_IGNORED": 0,
       "SOURCE_IGNORED": 0,
       "MISSING": 0,
       "FOUND": 0,
       "AMBIGUOUS": 0,
       "UNQUALIFIED": 0,
       "CONFIRMED": 0,
       "SOURCE_MISSING": 0,
       "ABSENT": 1
     },
     "started": "2014-03-06T06:14:04.722Z"
   },
 ]
}</screen>

    <variablelist>
     <para>
      Each reconciliation run has the following properties:
     </para>
     <varlistentry>
      <term><literal>_id</literal></term>
      <listitem>
       <para>
        The ID of the reconciliation run.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>mapping</literal></term>
      <listitem>
       <para>
        The name of the mapping, defined in the <filename>conf/sync.json</filename>
        file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>state</literal></term>
      <listitem>
       <para>
        The high level state of the reconciliation run. Values can be as follows:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <literal>ACTIVE</literal>
         </para>
         <para>
          The reconciliation run is in progress.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>CANCELED</literal>
         </para>
         <para>
          The reconciliation run was successfully canceled.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>FAILED</literal>
         </para>
         <para>
          The reconciliation run was terminated because of failure.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>SUCCESS</literal>
         </para>
         <para>
          The reconciliation run completed successfully.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>stage</literal></term>
      <listitem>
       <para>
        The current stage of the reconciliation run's progress. Values can be as
        follows:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <literal>ACTIVE_INITIALIZED</literal>
         </para>
         <para>
          The initial stage, when a reconciliation run is first created.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_QUERY_ENTRIES</literal>
         </para>
         <para>
          Querying the source, target and possibly link sets to reconcile.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_RECONCILING_SOURCE</literal>
         </para>
         <para>
          Reconciling the set of IDs retrieved from the mapping source.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_RECONCILING_TARGET</literal>
         </para>
         <para>
          Reconciling any remaining entries from the set of IDs retrieved from
          the mapping target, that were not matched or processed during the
          source phase.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_LINK_CLEANUP</literal>
         </para>
         <para>
          Checking whether any links are now unused and should be cleaned up.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_PROCESSING_RESULTS</literal>
         </para>
         <para>
          Post-processing of reconciliation results.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>ACTIVE_CANCELING</literal>
         </para>
         <para>
          Attempting to abort a reconciliation run in progress.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>COMPLETED_SUCCESS</literal>
         </para>
         <para>
          Successfully completed processing the reconciliation run.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>COMPLETED_CANCELED</literal>
         </para>
         <para>
          Completed processing because the reconciliation run was aborted.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>COMPLETED_FAILED</literal>
         </para>
         <para>
          Completed processing because of a failure.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>stageDescription</literal></term>
      <listitem>
       <para>
        A description of the stages described previously.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>progress</literal></term>
      <listitem>
       <para>
        The progress object has the following structure (annotated here with
        comments):
       </para>
       <programlisting language="javascript" width="91">
"progress":{
  "source":{             // Progress on set of existing entries in the mapping source
    "existing":{
      "processed":1001,
        "total":"1001"   // Total number of entries in source set, if known, ? otherwise
    }
  },
  "target":{             // Progress on set of existing entries in the mapping target
    "existing":{
      "processed":1001,
      "total":"1001"     // Total number of entries in target set, if known, ? otherwise
    },
    "created":0          // New entries that were created
  },
  "links":{              // Progress on set of existing links between source and target
    "existing":{
      "processed":1001,
      "total":"1001"     // Total number of existing links, if known, ? otherwise
    },
  "created":0            // Denotes new links that were created
  }
},
       </programlisting>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>

  <section xml:id="livesync-over-rest">
   <title>Triggering LiveSync Over REST</title>
   <para>
    The ability to trigger LiveSync operations over REST, or by using the
    resource API, enables you to use an external scheduler to trigger a LiveSync
    operation, rather than using the OpenIDM scheduling mechanism.
   </para>

   <itemizedlist>
    <para>
     There are two ways in which to trigger a LiveSync operation over REST.
    </para>
    <listitem>
     <para>
      Use the <literal>_action=liveSync</literal> parameter directly on the
      resource. This is the recommended method. The following example calls a
      LiveSync operation on the user accounts in an external LDAP system.
     </para>
     <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system/ldap/account?_action=liveSync"</screen>
    </listitem>
    <listitem>
     <para>
      Target the <literal>system</literal> endpoint and supply a
      <literal>source</literal> parameter to identify the object that should be
      synchronized. This method matches the scheduler configuration and can
      therefore be used to test schedules before they are implemented.
     </para>
     <para>
      The following example calls the same LiveSync operation as the previous
      example.
     </para>
     <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system?_action=liveSync&amp;source=system/ldap/account"</screen>
    </listitem>
   </itemizedlist>

   <para>
    A successful LiveSync operation returns the following response:
   </para>
   <screen>{
    "_rev": "4",
    "_id": "SYSTEMLDAPACCOUNT",
    "connectorData": {
        "nativeType": "integer",
        "syncToken": 1
    }
}</screen>
   <para>
    Do not run two identical LiveSync operations simultaneously - rather, ensure
    that the first operation has completed before a second similar operation is
    launched.
   </para>
   <para>
    To troubleshoot a LiveSync operation that has not succeeded, you can include
    an optional parameter (<literal>detailedFailure</literal>) to return
    additional information. For example:
   </para>
   <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system/ldap/account?_action=liveSync&amp;detailedFailure=true"</screen>

   <note>
    <para>
     The first time that a LiveSync operation is called, no synchronization
     token exists in the database to establish which changes have already been
     processed. The default LiveSync behavior is to locate the last existing
     entry in the change log, and to store that entry in the database as the
     current starting position from which changes should be applied. This
     behavior prevents LiveSync from processing changes that might already have
     been processed during an initial data load. Subsequent LiveSync operations
     will pick up and process any new changes.
    </para>
    <para>
     Typically, in setting up LiveSync on a new system, you would load the data
     initially (by using reconciliation, for example) and then enable LiveSync,
     starting from that base point.
    </para>
   </note>
  </section>
 </section>

 <section xml:id="recon-by-query">
  <title>Restricting Reconciliation by Using Queries</title>
  <para>
   Every reconciliation operation performs a query on the source, and on the
   target resource, to determine which records should be reconciled. The default
   source and target queries are <literal>query-all-ids</literal>, which means
   that all records in both the source and the target are considered candidates
   for that reconciliation operation.
  </para>
  <para>
   You can restrict reconciliation to specific entries by defining explicit
   source or target queries in the mapping configuration.
  </para>
  <para>
   For example, to restrict reconciliation to only those records whose
   <literal>employeeType</literal> on the source resource is
   <literal>Permanent</literal>, you might specify a source query as follows:
  </para>
  <programlisting language="javascript">"mappings" : [
     {
         "name" : "managedUser_systemLdapAccounts",
         "source" : "managed/user",
         "target" : "system/ldap/account",
         "sourceQuery" : {
            "_queryFilter" : "employeeType eq \"Permanent\""
         },
...</programlisting>
  <para>
   The format of the query can be any query type that is supported by the
   resource, and can include additional parameters, if applicable. OpenIDM
   ${docTargetVersion} supports the following query types.
  </para>
  <itemizedlist>
   <para>
    For queries on managed objects:
   </para>
   <listitem>
    <para>
     <literal>_queryId</literal> for arbitrary predefined, parameterized
     queries
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>_queryFilter</literal> for arbitrary filters, in common filter
     notation
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>_queryExpression</literal> for client-supplied queries, in native
     query format
    </para>
   </listitem>
  </itemizedlist>
  <itemizedlist>
   <para>
    For queries on system objects:
   </para>
   <listitem>
    <para>
     <literal>_queryId=query-all-ids</literal> (the only supported predefined
     query)
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>_queryFilter</literal> for arbitrary filters, in common filter
     notation
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The source and target queries send the query to the resource that is defined
   for that source or target, by default. You can override the resource to which
   the query is sent by specifying a <literal>resourceName</literal> in the
   query. For example, to query a specific endpoint instead of the source
   resource, you might modify the preceding source query as follows:
  </para>
  <programlisting language="javascript">"mappings" : [
    {
        "name" : "managedUser_systemLdapAccounts",
        "source" : "managed/user",
        "target" : "system/ldap/account",
        "sourceQuery" : {
            "resourceName" : "endpoint/scriptedQuery"
            "_queryFilter" : "employeeType eq \"Permanent\""
        },
...</programlisting>
  <para>
   To override a source or target query that is defined in the mapping, you can
   specify the query when you call the reconciliation operation. For example, if
   you wanted to reconcile all employee entries, and not just the permanent
   employees, you would run the reconciliation operation as follows:
  </para>
  <screen>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 --data '{"sourceQuery": {"_queryId" : "query-all-ids"}}' \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=managedUser_systemLdapAccounts"</screen>
  <para>
   By default, a reconciliation operation runs both the source and target phase.
   To avoid queries on the target resource, set
   <literal>runTargetPhase</literal> to <literal>false</literal> in the mapping
   configuration (<filename>conf/sync.json</filename> file). For example, to
   prevent the target resource from being queried during the reconciliation
   operation configured in the previous example, amend the mapping configuration
   as follows:
  </para>
  <programlisting>{
    "mappings" : [
        {
            "name" : "systemLdapAccounts_managedUser",
            "source" : "system/ldap/account",
            "target" : "managed/user",
            "sourceQuery" : {
                "_queryFilter" : "employeeType eq \"Permanent\""
            },
            "runTargetPhase" : false,
   ...  </programlisting>

  <para>
   You can also restrict reconciliation by using queries, through the Admin UI
   at <literal>https://localhost:8443/admin</literal>. Navigate to
   Configure &gt; Mappings, select a Mapping &gt; Association &gt;
   Reconciliation Query Filters. You can then specify desired
   source and target queries.
  </para>

  <section xml:id="recon-query-optimization">
   <title>Improving Reconciliation Query Performance</title>
   <para>
    In most reconciliation configurations, source and target queries make a read
     call to every record on the source and target systems, to determine
    candidates for reconciliation. On slow source or target systems, these
    frequent calls can incur a substantial performance cost.
   </para>
   <para>
    To improve query performance in these situations, you can preload the entire
    result set into memory on the source or target system, or on both systems.
    Subsequent read queries on known IDs are made against the data in memory,
    rather than the data on the remote system. For this optimization to be
    effective, the entire result set must fit into the available memory on the
    system for which it is enabled.
   </para>
   <para>
    The optimization works by defining a <literal>sourceQuery</literal> or
    <literal>targetQuery</literal> in the synchronization mapping that returns
    not just the ID, but the complete object.
   </para>
   <para>
    The following example query loads the full result set into memory during the
    source phase of the reconciliation. The example uses a common filter
    expression, called with the <literal>_queryFilter</literal> keyword. The
    query returns the complete object for all entries that include a
    <literal>uid</literal> (<literal>uid sw ""</literal>).
   </para>
   <programlisting language="javascript">"mappings" : [
    {
        "name" : "systemLdapAccounts_managedUser",
        "source" : "system/ldap/account",
        "target" : "managed/user",
        "sourceQuery" : {
            "_queryFilter" : "uid sw \"\""
        },
    ...</programlisting>
   <para>
    OpenIDM automatically attempts to detect what has been returned. The
    auto-detection mechanism assumes that a result set that includes three or
    more fields per object (apart from the <literal>_id</literal> and
    <literal>rev</literal> fields) contains the complete object.
   </para>
   <para>
    You can explicitly state whether a query is configured to return complete
    objects by setting the value of <literal>sourceQueryFullEntry</literal> or
    <literal>targetQueryFullEntry</literal> in the mapping. The setting of these
    properties overrides the auto-detection mechanism.
   </para>
   <para>
    Setting these properties to <literal>false</literal>, indicates that the
    returned object is not the complete object. This might be required if a
    query returns more than three fields of an object, but not the complete
    object. Without this setting, the auto-detect logic would assume that the
    complete object was being returned in this case. OpenIDM uses only the IDs
    from this query result. If the complete object is required, the object is
    queried on demand.
   </para>
   <para>
    Setting these properties to <literal>true</literal> indicates that the
    complete object is returned. This setting is typically required only for
    very small objects, for which the number of returned fields does not reach
    the threshold required for the auto-detection mechanism to assume that it is
    a full object. In this case, the query result includes all the details
    required to pre-load the full object.
   </para>
   <para>
    The following excerpt of the synchronization mapping file indicates that
    the full objects are returned and that OpenIDM should not autodetect the
    result set.
   </para>
   <programlisting language="javascript">"mappings" : [
    {
        "name" : "systemLdapAccounts_managedUser",
        "source" : "system/ldap/account",
        "target" : "managed/user",
        "sourceQueryFullEntry" : true,
        "sourceQuery" : {
            "_queryFilter" : "uid sw \"\""
        },
    ...</programlisting>
  </section>

  <section xml:id="recon-paging">
   <title>Configuring Reconciliation Paging</title>
   <indexterm>
    <primary>Reconciliation</primary>
    <secondary>Paging</secondary>
   </indexterm>
   <para>
    <xref linkend="recon-query-optimization" /> describes how to improve
    reconciliation performance by loading all entries into memory to avoid
    making individual requests to the external system for every ID. However,
    this optimization depends on the entire result set fitting into the
    available memory on the system for which it is enabled. For particularly
    large data sets (for example, data sets of hundreds of millions of users),
    having the entire data set in memory might not be feasible.
   </para>
   <para>
    To alleviate this constraint, OpenIDM supports a paged reconciliation
    mechanism that enables reconciliation of extremely large data sets to be
    broken down into chunks. Reconciliation paging enables you to specify the
    number of entries that should be reconciled in each chunk or page.
   </para>
   <para>
    Reconciliation paging is disabled by default, and can be enabled per mapping
    (in the <filename>sync.json</filename> file). To configure reconciliation
    paging, set the <literal>"reconSourceQueryPaging"</literal> property to
    <literal>true</literal> and set the
    <literal>"reconSourceQueryPageSize"</literal> in the synchronization
    mapping, for example:
   </para>
   <programlisting language="javascript">{
    "mappings" : [
        {
            "name" : "systemLdapAccounts_managedUser",
            "source" : "system/ldap/account",
            "target" : "managed/user",
            "reconSourceQueryPaging" : true,
            "reconSourceQueryPageSize" : 100,
            ...
        }</programlisting>
   <para>
    The value of <literal>"reconSourceQueryPageSize"</literal> must be a
    positive integer, and specifies the number of entries that will be processed
    in each page. If reconciliation paging is enabled, but no page size is set,
    a default page size of <literal>1000</literal> is used.
   </para>
  </section>

 </section>

 <section xml:id="recon-by-id">
  <title>Restricting Reconciliation to a Specific ID</title>
  <para>
   In the same way that you can restrict reconciliation operations to specific
   records by using queries, you can specify an ID to restrict a reconciliation
   operation to a particular record.
  </para>
  <para>
   To restrict reconciliation to a specific ID, use the
   <literal>reconById</literal> action, instead of the <literal>recon</literal>
   action when you call the reconciliation operation. Specify the ID with the
   <literal>ids</literal> parameter. Currently reconciling more than one ID with
   the <literal>reconById</literal> action is not supported.
  </para>
  <para>
   The following example is based on the data from Sample 2b, which maps an
   LDAP server with the OpenIDM repository. The example reconciles only the user
   <literal>bjensen</literal>, using the
   <literal>managedUser_systemLdapAccounts</literal> mapping to update the user
   account in LDAP with the data from the OpenIDM repository. The
   <literal>_id</literal> for <literal>bjensen</literal> in this example is
   <literal>b3c2f414-e7b3-46aa-8ce6-f4ab1e89288c</literal>.
   The example assumes that implicit synchronization has been disabled and that
   a reconciliation operation is required to copy changes made in the repository
   to the LDAP system.
  </para>
  <screen width="102">$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=reconById&amp;mapping=managedUser_systemLdapAccounts&amp;ids=b3c2f414-e7b3-46aa-8ce6-f4ab1e89288c"</screen>
  <para>
   A reconciliation by ID takes the default reconciliation options that are
   specified in the mapping, so the source and target queries, and source and
   target phases described in the previous section apply equally to
   reconciliation by ID.
  </para>
 </section>

 <section xml:id="livesync-retry-strategy">
   <title>Configuring the LiveSync Retry Policy</title>
   <para>
    OpenIDM enables you to specify what should happen if a LiveSync operation
    reports a failure for an operation. By configuring the LiveSync retry
    policy, you can specify how many times a failed modification should be
    reattempted and what should happen in the event that the modification is
    unsuccessful after the specified number of attempts. If no retry policy is
    configured, OpenIDM reattempts the change an infinite number of times, until
    the change is successful. This behavior can increase data consistency in the
    case of transient failures (for example, when the connection to the database
    is temporarily lost). However, in situations where the cause of the failure
    is permanent (for example, if the change does not meet certain policy
    requirements) the change will never succeed, regardless of the number of
    attempts. In this case, the infinite retry behavior can effectively block
    subsequent LiveSync operations from starting.
   </para>
   <para>
    Generally, a scheduled reconciliation operation will eventually force
    consistency. However, to prevent repeated retries that block the LiveSync
    mechanism, you should restrict the number of times OpenIDM reattempts the
    same modification. You can then specify what OpenIDM does with failed
    LiveSync changes. The failed modification can be stored in a "dead letter
    queue", discarded, or reapplied. Alternatively, an administrator can be
    notified of the failure by email or by some other means. This behavior can
    be scripted. The default configuration, in the samples provided with
    OpenIDM, is to retry a failed modification five times, and then to log and
    ignore the failure.
   </para>
   <para>
    The LiveSync retry policy is configured in the connector configuration file
    (<filename>provisioner.openicf-*.json</filename>). The sample connector
    configuration files have a retry policy defined as follows:
   </para>
   <programlisting language="javascript">
"syncFailureHandler" : {
  "maxRetries" : 5,
  "postRetryAction" : "logged-ignore"
},
   </programlisting>
   <para>
    The <literal>maxRetries</literal> field specifies the number of attempts
    that OpenIDM should make to process the failed modification. The value of
    this property must be a positive integer, or <literal>-1</literal>. A value
    of zero indicates that failed modifications should not be reattempted. In
    this case, the post retry action is executed immediately when a LiveSync
    operation fails. A value of <literal>-1</literal> (or omitting the
    <literal>maxRetries</literal> property, or the entire
    <literal>syncFailureHandler</literal> from the configuration) indicates that
    failed modifications should be retried an infinite number of times. In this
    case, no post retry action is executed.
   </para>
   <para>
    The default retry policy relies on the scheduler, or whatever invokes the
    LiveSync operation. Therefore, if retries are enabled and a LiveSync
    modification fails, OpenIDM will retry the modification the next time that
    LiveSync is invoked.
   </para>
   <para>
    The <literal>postRetryAction</literal> field indicates what action OpenIDM
    should take in the event that the maximum number of retries has been reached
    (or if <literal>maxRetries</literal> has been set to zero). The post retry
    action can be one of the following:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>logged-ignore</literal> indicates that OpenIDM should ignore the
      failed modification, and log its occurrence.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>dead-letter-queue</literal> indicates that OpenIDM should save
      the details of the failed modification in a table in the repository
      (accessible over REST at
      <literal>repo/synchronisation/deadLetterQueue/<replaceable>provisioner-name</replaceable></literal>).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>script</literal> specifies a custom script that should be
      executed when the maximum number of retries has been reached. For
      information about using custom scripts in the configuration, see the
      <link xlink:href="integrators-guide#appendix-scripting"
      xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Scripting
      Reference</citetitle></link>.
     </para>
     <para>
      In addition to the regular objects described in the Scripting Reference,
      the following objects are available in the script scope:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <literal>syncFailure</literal>
       </para>
       <para>
        Provides details about the failed record. The structure of the
        <literal>syncFailure</literal> object is as follows:
       </para>
       <programlisting language="javascript">
"syncFailure" :
  {
    "token" : <replaceable>the ID of the token</replaceable>,
    "systemIdentifier" : <replaceable>a string identifier that matches the "name" property in
                         provisioner.openicf.json</replaceable>,
    "objectType" : <replaceable>the object type being synced, one of the keys in the
                   "objectTypes" property in provisioner.openicf.json</replaceable>,
    "uid" : <replaceable>the UID of the object (for example uid=joe,ou=People,dc=example,dc=com)</replaceable>,
    "failedRecord", <replaceable>the record that failed to synchronize</replaceable>
  },
       </programlisting>
       <para>
        To access these fields, include
        <literal>syncFailure.<replaceable>fieldname</replaceable></literal> in
        your script.
       </para>
      </listitem>
      <listitem>
       <para>
        <literal>failureCause</literal>
       </para>
       <para>
        Provides the exception that caused the original LiveSync failure.
       </para>
      </listitem>
      <listitem>
       <para>
        <literal>failureHandlers</literal>
       </para>
       <para>
        OpenIDM currently provides two synchronization failure handlers "out of
        the box". <literal>loggedIgnore</literal> indicates that the failure
        should be logged, after which no further action should be taken.
        <literal>deadLetterQueue</literal> indicates that the failed record
        should be written to a specific table in the repository, where further
        action can be taken. To invoke one of the internal failure handlers from
        your script, use a call similar to the following (shown here for
        JavaScript):
       </para>
       <screen>failureHandlers.deadLetterQueue.invoke(syncFailure, failureCause);</screen>
      </listitem>
     </itemizedlist>
     <para>
      Two sample scripts are provided in
      <filename>path/to/openidm/samples/syncfailure/script</filename>, one that
      logs failures, and one that sends them to the dead letter queue in the
      repository.</para>
     </listitem>
    </itemizedlist>

    <para>
     The following sample provisioner configuration file extract shows a
     LiveSync retry policy that specifies a maximum of four retries before the
     failed modification is sent to the dead letter queue.
    </para>

    <programlisting language="javascript">
...
"connectorName" : "org.identityconnectors.ldap.LdapConnector"
    },<emphasis role="heavy">

    "syncFailureHandler" : {
        "maxRetries" : 4,
        "postRetryAction" : dead-letter-queue
    },</emphasis>
    "poolConfigOption" : {
...
    </programlisting>

    <para>
     In the case of a failed modification, a message similar to the following is
     output to the log file:
    </para>
    <screen>INFO: sync retries = 1/4, retrying</screen>
    <para>
     OpenIDM reattempts the modification, the specified number of times. If the
     modification is still unsuccessful, a message similar to the following is
     logged:
    </para>
    <screen><?dbfo pgwide="1"?>INFO: sync retries = 4/4, retries exhausted
Jul 19, 2013 11:59:30 AM
    org.forgerock.openidm.provisioner.openicf.syncfailure.DeadLetterQueueHandler invoke
INFO: uid=jdoe,ou=people,dc=example,dc=com saved to dead letter queue
    </screen>
    <para>
     The log message indicates the entry for which the modification failed
     (<literal>uid=jdoe</literal>, in this example).
    </para>
    <para>You can view the failed modification in the dead letter queue, over
     the REST interface, as follows:
    </para>
    <screen><?dbfo pgwide="1"?>$ <userinput>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/repo/synchronisation/deadLetterQueue/ldap?_queryId=query-all-ids"</userinput>
     <computeroutput>{
       "query-time-ms": 2,
       "result":
       [
           {
               "_id": "4",
               "_rev": "0"
           }
       ],
       "conversion-time-ms": 0
    }</computeroutput></screen>
    <para>
     To view the details of a specific failed modification, include its ID in
     the URL:
    </para>
    <screen>$ <userinput>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/repo/synchronisation/deadLetterQueue/ldap/4"</userinput>
     <computeroutput>{
  "objectType": "account",
  "systemIdentifier": "ldap",
  "failureCause": "org.forgerock.openidm.sync.SynchronizationException:
            org.forgerock.openidm.objset.ConflictException:
            org.forgerock.openidm.sync.SynchronizationException:
            org.forgerock.openidm.script.ScriptException:
            ReferenceError: \"bad\" is not defined.
            (PropertyMapping/mappings/0/properties/3/condition#1)",
  "token": 4,
  "failedRecord": "<replaceable>complete record, in xml format</replaceable>"
  "uid": "uid=jdoe,ou=people,dc=example,dc=com",
  "_rev": "0",
  "_id": "4"
}   </computeroutput></screen>
   </section>

 <section xml:id="disabling-automatic-sync">
  <title>Disabling Automatic Synchronization Operations</title>
   <para>
    By default, all mappings participate in automatic synchronization
    operations, that is, a change to a managed object is automatically
    synchronized to all resources for which the managed object is configured as
    a source. Similarly, if LiveSync is enabled for a system, changes to an
    object on that system are automatically propagated to the managed object
    repository. You can prevent a specific mapping from participating in this
    automatic synchronization by setting the <literal>"enableSync"</literal>
    property of that mapping to false. In the following example, implicit
    synchronization is disabled. This means that changes to objects in the
    internal repository are not automatically propagated to the LDAP directory.
    To propagate changes to the LDAP directory, reconciliation must be launched
    manually.
   </para>

   <programlisting language="javascript">
{
    "mappings" : [
        {
            "name" : "managedUser_systemLdapAccounts",
            "source" : "managed/user",
            "target" : "system/ldap/account",
            "enableSync" : false,
             ....
}
   </programlisting>
   <para>
    If <literal>enableSync</literal> is set to <literal>false</literal> for a
    system to managed user mapping (for example
    <literal>"systemLdapAccounts_managedUser"</literal>), LiveSync is disabled
    for that mapping.
   </para>
 </section>

 <section xml:id="sync-failure-compensation">
  <title>Configuring Synchronization Failure Compensation</title>
  <para>
   When implicit synchronization is used to push a large number of changes from
   the managed object repository to several external repositories, the process
   can take some time. Problems such as lost connections might happen, resulting
   in the changes being only partially synchronized.
  </para>
  <para>
   For example, if a Human Resources manager adds a group of new employees in
   one database, a partial synchronization might mean that some of those
   employees do not have access to their email or other systems.
  </para>
  <para>
   You can configure implicit synchronization such that the system reverts an
   entire synchronization operation, in the event that it was not completely
   successful. An example of such a configuration is illustrated in the OpenIDM
   Installation Guide, <link xlink:show="new"
   xlink:role="http://docbook.org/xlink/role/olink"
   xlink:href="install-guide#more-sample5b"><citetitle>Sample 5b - Failure
   Compensation With Multiple Resources</citetitle></link>. That sample
   demonstrates how OpenIDM compensates when synchronization to an external
   resource fails.
  </para>
  <para>
   Failure compensation works by using the optional <literal>onSync</literal>
   hook, which can be specified in the <filename>conf/managed.json</filename>
   file. The <literal>onSync</literal> hook can be used to provide failure
   compensation as follows:
  </para>
  <programlisting language="javascript">
...
"onDelete" : {
    "type" : "text/javascript",
    "file" : "ui/onDelete-user-cleanup.js"
    },
"onSync" : {
    "type" : "text/javascript",
    "file" : "compensate.js"
    },
"properties" : [
    ...
   </programlisting>
   <para>
    The <literal>onSync</literal> hook references a script
    (<filename>compensate.js</filename>), that is located in the
    <filename>/path/to/openidm/bin/defaults/script</filename> directory.
   </para>
   <para>
    When a managed object is changed, an implicit synchronization operation
    attempts to synchronize the change (and any other pending changes) with any
    external data store(s) for which a mapping is configured.
   </para>
   <para>
    The implicit synchronization process proceeds with each mapping, in the
    order in which the mappings are specified in <literal>sync.json</literal>.
   </para>
   <para>
    The <filename>compensate.js</filename> script is designed to avoid
    partial synchronization. If synchronization is successful, for all
    configured mappings, OpenIDM exits from the script.
   </para>
   <para>
    If an implicit synchronization operation fails for a particular resource,
    the <literal>onSync</literal> hook invokes the
    <filename>compensate.js</filename> script. This script attempts to revert
    the original change by performing another update to the managed object. This
    change, in turn, triggers another implicit synchronization operation to all
    external resources for which mappings are configured.
   </para>
   <para>
    If the synchronization operation fails again, the
    <literal>compensate.js</literal> script is triggered again. This time,
    however, the script recognizes that the change was originally called as a
    result of a compensation and aborts. OpenIDM logs warning messages related
    to the sync action
    (<literal>notifyCreate, notifyUpdate, notifyDelete</literal>), along with
    the error that caused the sync failure.
   </para>
   <para>
    If failure compensation is not configured, any issues with connections to an
    external resource can lead to data stores that are out of sync, such as the
    example cited earlier where some new employees do not have access to their
    corporate email accounts.
   </para>
   <para>
    With the <filename>compensate.js</filename> script, any such errors will
    result in each data store using the information it had before the implicit
    synchronization operation started. OpenIDM stores that information,
    temporarily, in properties such as <literal>oldObject</literal> and
    <literal>oldTarget</literal>.
   </para>
   <para>
    In this particular example, human resource managers should see that
    new employees are not shown in their database. Then, the administrators
    of the OpenIDM system can check log files for errors, address them, and
    then restart the implicit synchronization process with a new REST call.
   </para>
  </section>

 <section xml:id="handling-sync">
  <title>Synchronization Situations and Actions</title>
   <indexterm>
    <primary>Synchronization</primary>
    <secondary>Situations</secondary>
   </indexterm>
   <indexterm>
    <primary>Synchronization</primary>
    <secondary>Actions</secondary>
   </indexterm>

  <para>
   During synchronization, OpenIDM categorizes objects according to their
   <firstterm>situation</firstterm>. Situations are characterized by whether an
   object exists on a source or target system, whether OpenIDM has registered a
   link between the source object and the target object, and whether the object
   is considered <firstterm>valid</firstterm>, as assessed by the
   <literal>validSource</literal> and <literal>validTarget</literal> scripts.
   OpenIDM then takes a specific action, depending on the situation.
  </para>

  <para>
   You can define actions for particular situations in the
   <literal>policies</literal> section of a synchronization mapping, as shown in
   the following excerpt from the <filename>sync.json</filename> file of
   Sample 2b.
  </para>

  <programlisting language="javascript">
{
    "policies": [
        {
            "situation": "CONFIRMED",
            "action": "UPDATE"
        },
        {
            "situation": "FOUND",
            "action": "UPDATE"
        },
        {
            "situation": "ABSENT",
            "action": "CREATE"
        },
        {
            "situation": "AMBIGUOUS",
            "action": "EXCEPTION"
        },
        {
            "situation": "MISSING",
            "action": "CREATE"
        },
        {
            "situation": "SOURCE_MISSING",
            "action": "DELETE"
        {
            "situation": "UNQUALIFIED",
            "action": "IGNORE"
        },
        {
            "situation": "UNASSIGNED",
            "action": "IGNORE"
        }
    ]
}</programlisting>

  <para>
   If you do not define a policy for a particular situation, OpenIDM takes the
   <firstterm>default action</firstterm> for the situation.
  </para>
  <para>
   The following sections describe the possible situations and their default
   corresponding actions. You can also view these situations and actions in the
   Admin UI. Navigate to <literal>https://localhost:8443/admin</literal>,
   log in as the <literal>openidm-admin</literal> user, select
   Configure &gt; Mappings, select a Mapping &gt; Behaviors &gt; Policies.
  </para>

  <section xml:id="sync-situations">
   <title>Synchronization Situations</title>

   <orderedlist>
    <para>
     OpenIDM performs a reconciliation operation in two phases:
    </para>
    <listitem>
     <para>
      <firstterm>Source reconciliation</firstterm>, where OpenIDM accounts for
      source objects and associated links, based on the configured mapping.
     </para>
    </listitem>
    <listitem>
     <para>
      <firstterm>Target reconciliation</firstterm>, where OpenIDM iterates over
      the target objects that were not processed in the first phase.
     </para>
    </listitem>
   </orderedlist>

   <orderedlist>
    <para>
     During the source reconciliation phase, OpenIDM builds three lists,
     assigning values to the objects to reconcile.
    </para>
    <listitem>
     <para>
      All valid objects from the source
     </para>
     <para>
      OpenIDM assigns valid source objects <literal>qualifies=1</literal>.
      Invalid objects, including those that were not found in the source system,
      and those that were filtered out by the script specified in the
      <literal>validSource</literal> property, are assigned
      <literal>qualifies=0</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      All records from the appropriate links table
     </para>
     <para>
      Objects that have a corresponding link in the links table of the
      repository are assigned <literal>link=1</literal>. Objects that do not
      have a corresponding link are assigned <literal>link=0</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      All valid objects on the target system
     </para>
     <para>
      Objects that are found in the target system are assigned
      <literal>target=1</literal>. Objects that are not found in the target
      system are assigned <literal>target=0</literal>.
     </para>
    </listitem>
   </orderedlist>

   <variablelist>
    <para>
     Based on the values assigned to objects during source reconciliation,
     OpenIDM assigns situations, listed here with default and appropriate
     alternative actions.
    </para>
    <varlistentry>
     <term>"CONFIRMED" (qualifies=1, link=1, target=1)</term>
     <listitem>
      <para>
       The source object qualifies for a target object, and a link to an
       existing target object was found. This situation is detected during
       change events and during reconciliation.
      </para>

      <para>
       Default action: <literal>UPDATE</literal> the target object.
      </para>

      <para>
       Other valid actions: <literal>IGNORE, REPORT, NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"FOUND" (qualifies=1, link=0, target=1)</term>
     <listitem>
      <para>
       The source object qualifies for a target object and there is no link to
       an existing target object. There is a single target object, that
       correlates with this source object, according to the logic in the
       correlation. This situation is detected during change events and
       reconciliation.
      </para>

      <para>
       Default action: <literal>UPDATE</literal> the target object.
      </para>

      <para>
       Other valid actions: <literal>EXCEPTION, IGNORE, REPORT,
       NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"FOUND_ALREADY_LINKED" (qualifies=1, link=1, target=1)</term>
     <listitem>
      <para>
       The source object qualifies for a target object and there is no link from
       that source object to an existing target object. There is a single target
       object, that correlates with this source object, according to the logic
       in the correlation, but that target object is already linked to a
       different source object. This situation is detected during change events
       and reconciliation.
      </para>

      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>

      <para>
       Other valid actions: <literal>IGNORE, REPORT, NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"ABSENT" (qualifies=1, link=0, target=0)</term>
     <listitem>
      <para>
       The source object qualifies for a target object, there is no link to an
       existing target object, and there is no correlated target object found.
       This situation is detected during change events and reconciliation.
      </para>

      <para>
       Default action: <literal>CREATE</literal> a target object.
      </para>

      <para>
       Other valid actions: <literal>EXCEPTION, IGNORE, REPORT, NOREPORT, ASYNC
      </literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"AMBIGUOUS" (qualifies=1, link=0, target&gt;1)</term>
     <listitem>
      <para>
       The source object qualifies for a target object, there is no link to an
       existing target object, but there is more than one correlated target
       object (that is, more than one possible match on the target system). This
       situation is detected during source object changes and reconciliation.
      </para>
      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>

      <para>
       Other valid actions: <literal>IGNORE, REPORT, NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"MISSING" (qualifies=1, link=1, target=0)</term>
     <listitem>
      <para>
       The source object qualifies for a target object, and there is a link to a
       target object, but the target object is missing. This situation is
       detected during reconciliation operations and during source object changes.
      </para>
      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>
      <para>
       Other valid actions: <literal>CREATE, UNLINK, IGNORE, REPORT, NOREPORT.
      ASYNC</literal>
      </para>
      <para>
       Note that when a target object is deleted, the link from the target to
       the corresponding source object is not deleted automatically. This
       enables OpenIDM to detect and report on items that might have been
       removed without permission or that might need review. If your deployment
       requires that deleting a target object removes the corresponding link,
       you must define a back-mapping that enables OpenIDM to identify the
       deleted object as a source object, and remove the link.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"UNQUALIFIED" (qualifies=0, link=0 or 1, target=1 or &gt;1)</term>
     <listitem>
      <para>
       The source object is unqualified (by the "validSource" script). One or
       more target objects are found through the correlation logic. This
       situation is detected during change events and reconciliation.
      </para>
      <para>
       Default action: <literal>DELETE</literal> the target object or objects.
      </para>
      <para>
       Other valid actions: <literal>EXCEPTION, IGNORE, REPORT, NOREPORT,
      ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"TARGET_IGNORED" (qualifies=0, link=0 or 1, target=1)</term>
     <listitem>
      <para>
       The source object is unqualified (by the "validSource" script). One or
       more target objects are found through the correlation logic. This
       situation is detected only during source object changes.
      </para>
      <para>
       It is different from "UNQUALIFIED", based on the status of the link and
       target. If there is a link, the target is not valid. If there is no link
       and exactly one target, that target is not valid.
      </para>
      <para>
       Default action: <literal>IGNORE</literal> the target object until the
       next full reconciliation operation.
      </para>
      <para>
       Other valid actions: <literal>DELETE, UNLINK, EXCEPTION, REPORT,
       NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"SOURCE_IGNORED" (qualifies=0, link=0, target=0)</term>
     <listitem>
      <para>
       The source object is unqualified (by the "validSource" script), no link
       is found, and no correlated target exists. This situation is detected
       during source object changes and reconciliation.
      </para>
      <para>
       Default action: <literal>IGNORE</literal> the source object.
      </para>
      <para>
       Other valid actions: <literal>EXCEPTION, REPORT, NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"LINK_ONLY" (qualifies=n/a, link=1, target=0)</term>
     <listitem>
      <para>
       The source may or may not be qualified, a link is found, but no target
       object is found. This situation is detected only during source object
       changes.
      </para>
      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>
      <para>
       Other valid actions: <literal>UNLINK, IGNORE, REPORT, NOREPORT,
       ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"ALL_GONE" (qualifies=n/a, link=0, cannot-correlate)</term>
     <listitem>
      <para>
       The source object has been removed. No link is found. Correlation is not
       possible, for one of the following reasons:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         No previous source value can be found.
        </para>
       </listitem>
       <listitem>
        <para>
         There is no correlation logic used.
        </para>
       </listitem>
       <listitem>
        <para>
         A previous value was found, and correlation logic exists, but no
         corresponding target was found.
        </para>
       </listitem>
      </itemizedlist>
      <para>This situation is detected only during source object changes.
      </para>
      <para>
       Default action: "IGNORE" the source object.
      </para>
      <para>
       Other valid actions: <literal>EXCEPTION, REPORT, NOREPORT,
      ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <orderedlist>
    <para>
     During the target reconciliation phase, OpenIDM assigns the following
     values as it iterates through the target objects that were not accounted
     for during the source reconciliation.
    </para>
    <listitem>
     <para>
      Valid objects from the target
     </para>
     <para>
      OpenIDM assigns valid target objects <literal>qualifies=1</literal>.
      Invalid objects, including those that are filtered out by the script
      specified in the <literal>validTarget</literal> property, are assigned
      <literal>qualifies=0</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      All records from the appropriate links table
     </para>
     <para>
      Objects that have a corresponding link in the links table of the
      repository are assigned <literal>link=1</literal>. Objects that do not
      have a corresponding link are assigned <literal>link=0</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      All valid objects on the source system
     </para>
     <para>
      Objects that are found in the source system are assigned
      <literal>source=1</literal>. Objects that are not found in the source
      system are assigned <literal>source=0</literal>.
     </para>
    </listitem>
   </orderedlist>

    <para>
     Based on the values that are assigned to objects during the target
     reconciliation phase, OpenIDM assigns situations, listed here with their
     default actions.
    </para>
   <variablelist>
    <varlistentry>
     <term>"TARGET_IGNORED" (qualifies=0)</term>
     <listitem>
      <para>
       During target reconciliation, the target becomes unqualified by the
      "validTarget" script. This situation is detected only during
       reconciliation operations.
      </para>
      <para>
       Default action: <literal>IGNORE</literal> the target object.
      </para>
      <para>
       Other valid actions: <literal>DELETE, UNLINK, REPORT, NOREPORT,
      ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"UNASSIGNED" (qualifies=1, link=0)</term>
     <listitem>
      <para>
       A valid target object exists, for which there is no link. This situation
       is detected only during reconciliation operations.
      </para>
      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>
      <para>
       Other valid actions: <literal>IGNORE, REPORT, NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"CONFIRMED" (qualifies=1, link=1, source=1)</term>
     <listitem>
      <para>
       The target object qualifies, and a link to a source object exists. This
       situation is detected only during reconciliation operations.
      </para>
      <para>
       Default action: <literal>UPDATE</literal> the target object.
      </para>
      <para>
       Other valid actions: <literal>IGNORE, REPORT, NOREPORT</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"UNQUALIFIED" (qualifies=0, link=1, source=1, but source does not
     qualify)</term>
     <listitem>
      <para>
       The target object is unqualified, (by the "validTarget" script), but
       there is a link to an existing source object, which is also unqualified.
       This situation is detected during change events and reconciliation.
      </para>
      <para>
       Default action: <literal>DELETE</literal> the target object.
      </para>
      <para>
       Other valid actions: <literal>UNLINK, EXCEPTION, IGNORE, REPORT,
       NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>SOURCE_MISSING (qualifies=1, link=1, source=0)</term>
     <listitem>
      <para>
       The target object qualifies and a link is found, but the source object is
       missing. This situation is detected during change events and
       reconciliation.
      </para>
      <para>
       Default action: throw an <literal>EXCEPTION</literal>.
      </para>
      <para>
       Other valid actions: <literal>DELETE, UNLINK, IGNORE, REPORT,
       NOREPORT, ASYNC</literal>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    The following sections reiterate in detail how OpenIDM assigns situations
    during each of the two synchronization phases.
   </para>
  </section>

  <section xml:id="source-reconciliation">
   <title>Source Reconciliation</title>

   <para>
    OpenIDM starts reconciliation and LiveSync by reading a list of objects from
    the resource. For reconciliation, the list includes all objects that are
    available through the connector. For LiveSync, the list contains only
    changed objects. OpenIDM can filter objects out of the list by using the
    script specified in the <literal>validSource</literal> property, or the
    conditions defined in the <literal>sourceCondition</literal> property.
   </para>

   <para>
    OpenIDM then iterates over the list, checking each entry against the
    <literal>validSource</literal> and <literal>sourceCondition</literal>
    filters, and classifying objects according to their situations as described
    in <xref linkend="sync-situations"/>. OpenIDM uses the list of links for the
    current mapping to classify objects. Finally, OpenIDM executes the action
    that is configured for each situation.
   </para>

   <para>
    The following table shows how OpenIDM assigns the appropriate situation
    during source reconciliation, depending on whether a valid source exists
    (Source Qualifies), whether a link exists in the repository (Link Exists),
    and how many target objects are found, based either on links or on the
    results of the correlation.
   </para>

   <table pgwide="1" rules="none"><?dbfo font-size="6pt" ?>
    <title>Resolving Source Reconciliation Situations</title>
    <tgroup cols="8">
     <colspec colnum="1" colname="c1" />
     <colspec colnum="2" colname="c2" />
     <colspec colnum="3" colname="c3" />
     <colspec colnum="4" colname="c4" />
     <colspec colnum="5" colname="c5" />
     <colspec colnum="6" colname="c6" />
     <colspec colnum="7" colname="c7" />
     <colspec colnum="8" colname="c8" colwidth="4*" />
     <thead>
      <row>
       <entry namest="c1" nameend="c2" align="left">Source Qualifies?</entry>
       <entry namest="c3" nameend="c4" align="left">Link Exists?</entry>
       <entry namest="c5" nameend="c7" align="left">Target Objects
       Found<footnote><para>If no link exists for the source object, then
       OpenIDM executes correlation logic. If no previous object is available,
       OpenIDM cannot correlate.</para></footnote></entry>
       <entry morerows="1" valign="top" align="left">Situation</entry>
      </row>
      <row>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>0</entry>
       <entry>1</entry>
       <entry>&gt; 1</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>SOURCE_MISSING</entry>
      </row>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>UNQUALIFIED</entry>
      </row>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>UNQUALIFIED</entry>
      </row>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>TARGET_IGNORED</entry>
      </row>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>UNQUALIFIED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>ABSENT</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>FOUND</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X<footnote><para>A link exists from the target object but it is
        not for this specific source object.</para></footnote></entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>FOUND_ALREADY_LINKED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>AMBIGUOUS</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>MISSING</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>CONFIRMED</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </section>

  <section xml:id="target-reconciliation">
   <title>Target Reconciliation</title>

   <para>
    During source reconciliation, OpenIDM cannot detect situations where no
    source object exists, such as the UNASSIGNED situation. When no source
    object exists, OpenIDM detects the situation during the second
    reconciliation phase, target reconciliation. During target reconciliation,
    OpenIDM iterates over all target objects that do not have a representation
    on the source, checking each object against the
    <literal>validTarget</literal> filter, determining the appropriate situation,
    and executing the action configured for the situation.
   </para>

   <para>
    The following table shows how OpenIDM assigns the appropriate situation
    during target reconciliation, depending on whether a valid target exists
    (Target Qualifies), whether a link with an appropriate type exists in the
    repository (Link Exists), whether a source object exists (Source Exists),
    and whether the source object qualifies (Source Qualifies). Not all
    situations assigned during source reconciliation are assigned during target
    reconciliation.
   </para>

   <table pgwide="1" rules="none">
    <title>Resolving Target Reconciliation Situations</title>
    <tgroup cols="9">
     <colspec colnum="1" colname="c1" />
     <colspec colnum="2" colname="c2" />
     <colspec colnum="3" colname="c3" />
     <colspec colnum="4" colname="c4" />
     <colspec colnum="5" colname="c5" />
     <colspec colnum="6" colname="c6" />
     <colspec colnum="7" colname="c7" />
     <colspec colnum="8" colname="c8" />
     <colspec colnum="9" colname="c9" colwidth="4*" />
     <thead>
      <row>
       <entry namest="c1" nameend="c2" align="left">Target Qualifies?</entry>
       <entry namest="c3" nameend="c4" align="left">Link Exists?</entry>
       <entry namest="c5" nameend="c6" align="left">Source Exists?</entry>
       <entry namest="c7" nameend="c8" align="left">Source Qualifies?</entry>
       <entry morerows="1" valign="top" align="left">Situation</entry>
      </row>
      <row>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>Yes</entry>
       <entry>No</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>TARGET_IGNORED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>UNASSIGNED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>CONFIRMED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>UNQUALIFIED</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>SOURCE_MISSING</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </section>

  <section xml:id="autosync-and-livesync">
   <title>Situations Specific to Implicit Synchronization and LiveSync</title>
   <para>
    Certain situations occur only during implicit synchronization (when OpenIDM
    pushes changes made in the repository out to external systems) and LiveSync
    (when OpenIDM polls external system change logs for changes and updates the
    repository).
   </para>
   <para>
    The following table shows the situations that pertain only to implicit sync
    and LiveSync, when records are <emphasis>deleted</emphasis> from the source
    or target resource.
   </para>
   <table pgwide="1" rules="none">
    <title>Resolving Implicit Sync and LiveSync Delete Situations</title>
    <tgroup cols="8">
     <colspec colnum="1" colname="c1" />
     <colspec colnum="2" colname="c2" />
     <colspec colnum="3" colname="c3" />
     <colspec colnum="4" colname="c4" />
     <colspec colnum="5" colname="c5" />
     <colspec colnum="6" colname="c6" />
     <colspec colnum="7" colname="c7" />
     <colspec colnum="8" colname="c8" colwidth="4*" />
     <thead>
      <row>
       <entry namest="c1" nameend="c2" align="left">Source Qualifies?</entry>
       <entry namest="c3" nameend="c4" align="left">Link Exists?</entry>
       <entry namest="c5" nameend="c7" align="left">Target Objects Found
        <footnote>
         <para>
          If no link exists for the source object, OpenIDM executes any included
          correlation logic. If a link exists, correlation does not apply.
         </para>
        </footnote>
       </entry>
       <entry morerows="1" valign="top" align="left">Situation</entry>
      </row>
      <row>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>Yes</entry>
       <entry>No</entry>
       <entry>0</entry>
       <entry>1</entry>
       <entry>&gt; 1</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>N/A</entry>
       <entry>N/A</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>LINK_ONLY</entry>
      </row>
      <row>
       <entry>N/A</entry>
       <entry>N/A</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>ALL_GONE</entry>
      </row>
      <row>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>AMBIGUOUS</entry>
      </row>
      <row>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>&#160;</entry>
       <entry>&#160;</entry>
       <entry>X</entry>
       <entry>UNQUALIFIED</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </section>

  <section xml:id="sync-actions">
   <title>Synchronization Actions</title>

   <variablelist>
    <para>
     Once OpenIDM has assigned a situation to an object, OpenIDM takes the
     actions configured in the mapping. If no action is configured, then OpenIDM
     takes the default action for the situation. OpenIDM supports the following
     actions.
    </para>
    <varlistentry>
     <term>"CREATE"</term>
     <listitem>
      <para>Create and link a target object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"UPDATE"</term>
     <listitem>
      <para>Link and update a target object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"DELETE"</term>
     <listitem>
      <para>Delete and unlink the target object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"LINK"</term>
     <listitem>
      <para>Link the correlated target object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"UNLINK"</term>
     <listitem>
      <para>Unlink the linked target object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"EXCEPTION"</term>
     <listitem>
      <para>Flag the link situation as an exception.</para>
      <para>You should not use this action for LiveSync mappings.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"IGNORE"</term>
     <listitem>
      <para>Do not change the link or target object state.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"REPORT"</term>
     <listitem>
      <para>
       Do not perform any action but report on what would happen if the default
       action were performed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"NOREPORT"</term>
     <listitem>
      <para>
       Do not perform any action or generate any report.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>"ASYNC"</term>
     <listitem>
      <para>
       An asynchronous process has been started so do not perform any action or
       generate any report. <!--TODO Clarify this -->
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>

  <section xml:id="script-actions">
   <title>Launching a Script as an Action</title>
   <para>
    In addition to the static synchronization actions described in the previous
    section, you can provide a script that is run in specific synchronization
    situations. The script can be either JavaScript or Groovy, and can be
    provided inline (with the <literal>"source"</literal> property), or
    referenced from a file, (with the <literal>"file"</literal> property).
   </para>
   <para>
    The following extract of a sample <filename>sync.json</filename> file
    specifies that an inline script should be invoked, when a synchronization
    operation assesses an entry as <literal>ABSENT</literal> in the target
    system. The script checks whether the <literal>"employeeType"</literal>
    property of the corresponding source entry is <literal>"contractor"</literal>.
    If so, the entry is ignored. Otherwise, the entry is created on the target
    system.
   </para>
   <programlisting language="javascript">{
    "situation" : "ABSENT",
    "action" : {
        "type" : "text/javascript",
        "globals" : { },
        "source" : "if (source.employeeType === "contractor") {action='IGNORE'} else {action='CREATE'};action;"
    },
}  </programlisting>
   <para>
    The variables available to a script that is called as an action are
    <literal>source</literal>, <literal>target</literal>,
    <literal>linkQualifier</literal>, and <literal>recon</literal> (where
    <literal>recon.actionParam</literal> contains information about the current
    reconciliation operation). For more information about the variables
    available to scripts, see <link xlink:show="new"
    xlink:role="http://docbook.org/xlink/role/olink"
    xlink:href="integrators-guide#script-variables"><citetitle>Variables
    Available to Scripts</citetitle></link>.
   </para>
   <para>
    The result obtained from evaluating this script must be a string, whose
    value is one of the synchronization actions listed in
    <xref linkend="sync-actions" />. This resulting action will be shown in the
    reconciliation log.
   </para>
   <para>
    To launch a script as a synchronization action in the Admin UI, select your
    mapping, click on Behaviors, and edit the action for which you want the
    script to be launched.
   </para>
  </section>

  <section xml:id="workflow-actions">
   <title>Launching a Workflow as an Action</title>
   <para>
    OpenIDM provides a default script
    (<filename>triggerWorkflowFromSync.js</filename>) that enables you to launch
    a predefined workflow when a synchronization operation assesses a particular
    situation. The mechanism for triggering this script is the same as for any
    other script. The script is provided in the
    <literal>openidm/bin/defaults/script/workflow</literal> directory. If you
    customize the script, copy it to the <literal>script</literal> directory of
    your project, to ensure that your customizations are preserved during an
    upgrade.
   </para>
   <para>
    The parameters for the workflow are passed in as properties of the
    <literal>action</literal> parameter.
   </para>
   <para>
    The following extract of a sample <filename>sync.json</filename> file
    specifies that, when a synchronization operation assesses an entry as
    <literal>ABSENT</literal>, the workflow named
    <literal>managedUserApproval</literal> is invoked.
   </para>
   <programlisting language="javascript">{
    "situation" : "ABSENT",
    "action" : {
        "workflowName" : "managedUserApproval",
        "type" : "text/javascript",
        "file" : "workflow/triggerWorkflowFromSync.js"
    }
}  </programlisting>
   <para>
    To launch a workflow as a synchronization action in the Admin UI, select
    your mapping, click on Behaviors, and edit the action for which you want the
    workflow to be launched.
   </para>
  </section>

  <section xml:id="sync-link-qualifiers">
   <title>Using Link Qualifiers in Policies</title>

   <para>
    If you have configured managed objects such as users with more than one
    account, you can set different policies, per
    <emphasis>link qualifier</emphasis>, in the <filename>sync.json</filename>
    file.
   </para>
   <para>
    The process is similar to the following:
    <xref linkend="mapping-link-qualifiers" />.
   </para>
   <para>
    You can choose from the list of <literal>linkQualifiers</literal> defined
    near the start of the <filename>sync.json</filename> file. The following
    excerpt shows two <literal>linkQualifiers</literal>: <literal>user</literal>
    and <literal>test</literal>.
   </para>
   <programlisting language="javascript">{
    "mappings" : [
        {
            "name" : "systemLdapAccounts_managedUser",
            "source" : "system/ldap/account",
            "target" : "managed/user",
            "linkQualifiers" : [
                "user",
                "test"
        ],
    "properties" : [
    ... </programlisting>

   <para>
    Later in the same file, in the <literal>policies</literal> section, you can
    see different <literal>ABSENT</literal> actions for each link qualifier:
   </para>
   <programlisting language="javascript">
    "policies" : [
        {
             "situation" : "CONFIRMED",
             "action" : "IGNORE"
        },
        {
             "situation" : "FOUND",
             "action" : "IGNORE
        }
        {
             "condition" : "/linkQualifier eq \"user\""
             }
             "situation" : "ABSENT",
             "action" : "IGNORE",
             "postAction" : {
                 "type" : "text/javascript",
                 "source" : "java.lang.System.out.println('Ignored user: \');"
             }
        },
        {
            "condition : {
                "filter" : "/linkQualifier eq \"test\""
             }
            "situation" : "ABSENT",
            "action" : "CREATE",
            "postAction" : {
                "type" : "text/javascript",
                "source" : "java.lang.System.out.println('Created user: ');"
            }
        },
        ...
   </programlisting>
  </section>
 </section>

 <section xml:id="asynchronous-reconciliation">
  <title>Asynchronous Reconciliation</title>
  <para>
   Reconciliation can work in tandem with workflows to provide additional
   business logic to the reconciliation process. You can define scripts to
   determine the action that should be taken for a particular reconciliation
   situation. A reconciliation process can launch a workflow after it has
   assessed a situation, and then perform the reconciliation, or some other
   action.
  </para>
  <para>
   For example, you might want a reconciliation process to assess new user
   accounts that need to be created on a target resource. However, new user
   account creation might require some kind of approval from a manager before
   the accounts are actually created. The initial reconciliation process can
   assess the accounts that need to be created, launch a workflow to request
   management approval for those accounts, and then relaunch the reconciliation
   process to create the accounts, after the management approval has been
   received.
  </para>
  <para>
   In this scenario, the defined script returns <literal>IGNORE</literal> for
   new accounts and the reconciliation engine does not continue processing the
   given object. The script then initiates an asynchronous process which calls
   back and completes the reconciliation process at a later stage.
  </para>
  <para>
   A sample configuration for this scenario is available in
   <filename>openidm/samples/sample9</filename>, and described in <link
   xlink:href="install-guide#more-sample9"
   xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Sample 9 -
   Asynchronous Reconciliation Using Workflows</citetitle></link> in the
   <citetitle>Installation Guide</citetitle>.
  </para>

  <orderedlist>
   <para>
    Configuring asynchronous reconciliation using a workflow involves the
    following steps:
   </para>
   <listitem>
    <para>
     Create the workflow definition file (<literal>.xml or .bar</literal> file)
     and place it in the <filename>openidm/workflow</filename> directory. For
     more information about creating workflows, see <link
     xlink:href="integrators-guide#chap-workflow"
     xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Integrating
     Business Processes and Workflows</citetitle></link>.
    </para>
   </listitem>
   <listitem>
    <para>
     Modify the <filename>conf/sync.json</filename> file for the situation or
     situations that should call the workflow. Reference the workflow name in
     the configuration for that situation.
    </para>
    <para>
     For example, the following <filename>sync.json</filename> extract calls the
     <literal>managedUserApproval</literal> workflow if the situation is
     assessed as <literal>ABSENT</literal>:
    </para>
    <programlisting language="javascript">
{
    "situation" : "ABSENT",
    "action" : {
        "workflowName" : "managedUserApproval",
        "type" : "text/javascript",
        "file" : "workflow/triggerWorkflowFromSync.js"
    }
},  </programlisting>
   </listitem>
   <listitem>
    <para>
     In the sample configuration, the workflow calls a second, explicit
     reconciliation process as a final step. This reconciliation process is
     called on the <literal>sync</literal> context path, with the
     <literal>performAction</literal> action
     (<literal>openidm.action('sync', 'performAction', params)</literal>).
    </para>
   </listitem>
  </orderedlist>
  <para>
   You can also use this kind of explicit reconciliation to perform a specific
   action on a source or target record, regardless of the assessed situation.
  </para>
  <para>
   You can call such an operation over the REST interface, specifying the
   source, and/or target IDs, the mapping, and the action to be taken. The
   action can be any one of the supported reconciliation actions, that is,
   <literal>CREATE, UPDATE, DELETE, LINK, UNLINK, EXCEPTION, REPORT, NOREPORT,
   ASYNC, IGNORE</literal>.
  </para>
  <para>
   The following sample command calls the DELETE action on user
   <literal>bjensen</literal>, whose <literal>_id</literal> in the LDAP
   directory is <literal>uid=bjensen,ou=People,dc=example,dc=com</literal>.
   The user is deleted in the target resource, in this case, the OpenIDM
   repository.
  </para>
  <para>
   Note that the <literal>_id</literal> must be URL-encoded in the REST call.
  </para>
  <screen><userinput>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/sync?_action=performAction&amp;sourceId=uid%3Dbjensen%2Cou%3DPeople%2Cdc%3Dexample%2Cdc%3Dcom&amp;mapping=
 systemLdapAccounts_ManagedUser&amp;action=DELETE"</userinput>
<computeroutput>{}</computeroutput></screen>
  <para>
   The following example creates a link between a managed object and its
   corresponding system object. Such a call is useful in the context of manual
   data association, when correlation logic has linked an incorrect object,
   or when OpenIDM has been unable to determine the correct target object.
  </para>
  <para>
   In this example, there are two separate target accounts
   (<literal>scarter.user</literal> and <literal>scarter.admin</literal>) that
   should be mapped to the managed object. This call creates a link to the
   <literal>user</literal> account and specifies a
   <emphasis>link qualifier</emphasis> that indicates the type of link that
   will be created. For more information about mapping to multiple accounts,
   see <xref linkend="correlating-multiple-targets" />.
  </para>
  <screen><userinput>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/sync?_action=performAction&amp;action=LINK
   &amp;sourceId=4b39f74d-92c1-4346-9322-d86cb2d828a8&amp;targetId=scarter.user
   &amp;mapping=managedUser_systemXmlfileAccounts&amp;linkQualifier=user"</userinput>
<computeroutput>{}</computeroutput></screen>
 </section>

 <section xml:id="case-sensitivity">
   <title>Configuring Case Sensitivity for Data Stores</title>

   <para>By default, OpenIDM is case-sensitive, which means that case is taken
   into account when comparing IDs during reconciliation. For data stores that
   are case-insensitive, such as OpenDJ, IDs and links that are created by a
   reconciliation process may be stored with a different case to the way in
   which they are stored in the OpenIDM repository. Such a situation can cause
   problems during a reconciliation operation, as the links for these IDs may
   not match.</para>

   <para>For such data stores, you can configure OpenIDM to ignore case during
   reconciliation operations. With case sensitivity turned off in OpenIDM, for
   those specific mappings, comparisons are done without regard to case.</para>

   <para>To specify that data stores are not case-sensitive, set the
   <literal>"sourceIdsCaseSensitive"</literal> or <literal>"targetIdsCaseSensitive"</literal>
   property to <literal>false</literal> in the mapping for those links. For
   example, if the LDAP data store is case-insensitive, set the mapping from
   the LDAP store to the managed user repository as follows:</para>

   <programlisting language="javascript">
"mappings" : [
{
"name" : "systemLdapAccounts_managedUser",
"source" : "system/ldap/account",
"sourceIdsCaseSensitive" : false,
"target" : "managed/user",
"properties" : [
...
   </programlisting>

   <para>If a mapping inherits links by using the <literal>"links"</literal>
   property, it is not necessary to set case sensitivity, because the mapping
   uses the setting of the referred links.</para>

   <para>
    Note that configuring OpenIDM to be case-insensitive when comparing links
    does not make the OpenICF provisioner case-insensitive when it requests
    data. For example, if a user entry is stored with the ID
    <literal>testuser</literal> and you make a request for
    <literal>https://localhost:8443/openidm/managed/TESTuser</literal>, most
    provisioners will filter out the match because of the difference in case,
    and will indicate that the record is not found. To prevent the provisioner
    from performing this secondary filtering, set the
    <literal>enableFilteredResultsHandler</literal> property to
    <literal>false</literal> in the provisioner configuration. For example:
   </para>

   <screen>"resultsHandlerConfig" :
{
    "enableFilteredResultsHandler":false,
}, </screen>

   <caution>
     <para>Do not disable the filtered results handler for the CSV file
     connector. The CSV file connector does not perform filtering so if you
     disable the filtered results handler for this connector, the full CSV
     file will be returned for every request.</para>
   </caution>
 </section>

 <section xml:id="reconciliation-optimization">
  <title>Reconciliation Optimization</title>

  <para>By default, reconciliation is configured to function in an optimized
  way. Some of these optimizations might, however, be unsuitable for your
  environment. The following sections describe the optimizations and how they
  can be configured.</para>

  <section xml:id="correlate-target-set">
   <title>Correlating Empty Target Sets</title>

  <para>To optimize a reconciliation operation, the reconciliation process does
  not attempt to correlate source objects to target objects if the set of
  target objects is empty when the correlation is started. This considerably
  speeds up the process the first time the reconciliation is run. You can change
  this behavior for a specific mapping by adding the
  <literal>correlateEmptyTargetSet</literal> property to the mapping definition
  and setting it to <literal>true</literal>. For example:</para>

  <programlisting language="javascript">
{
    "mappings": [
        {
            "name"                     : "systemMyLDAPAccounts_managedUser",
            "source"                   : "system/MyLDAP/account",
            "target"                   : "managed/user",
            "correlateEmptyTargetSet"  : true
        },
    ]
}</programlisting>

   <para>Be aware that this setting will have a performance impact on the
   reconciliation process.</para>
   </section>

   <section xml:id="prefetching-links">
   <title>Prefetching Links</title>

   <para>
    All links are queried at the start of a reconciliation and the results of
    that query are used. You can disable the prefetching of links, so that the
    reconciliation process looks up each link in the database as it processes
    each source or target object. You can disable the prefetching of links by
    adding the <literal>prefetchLinks</literal> property to the mapping, and
    setting it to <literal>false</literal>, for example:
   </para>

   <programlisting language="javascript">
{
    "mappings": [
        {
            "name": "systemMyLDAPAccounts_managedUser",
            "source": "system/MyLDAP/account",
            "target": "managed/user"
            "prefetchLinks" : false
        }
    ]
}</programlisting>

   <para>Be aware that this setting will have a performance impact on the
   reconciliation process.</para>
   </section>

   <section xml:id="parallel-recon-tasks">
    <title>Parallel Reconciliation Threads</title>

    <para>By default, reconciliation is executed in a multi-threaded manner,
    that is, numerous threads are dedicated to the same reconciliation run.
    Multithreading generally improves reconciliation run performance. The
    default number of threads for a single reconciliation run is ten (plus the
    main reconciliation thread). Under normal circumstances, you should not
    need to change this number, however the default might not be appropriate
    in the following situations:</para>

    <itemizedlist>
      <listitem>
        <para>The hardware has many cores and supports more concurrent threads.
        As a rule of thumb for performance tuning, start with setting the
        thread number to two times the number of cores.</para>
      </listitem>
      <listitem>
       <para>The source or target is an external system with high latency or
       slow response times. Threads may then spend considerable time waiting
       for a response from the external system. Increasing the available
       threads enables the system to prepare or continue with additional
       objects.</para>
      </listitem>
    </itemizedlist>

    <para>To change the number of threads, set the <literal>taskThreads</literal>
    property in the <filename>conf/sync.json</filename> file, for example:</para>

    <programlisting language="javascript">
    "mappings" : [
        {
            "name" : "systemXmlfileAccounts_managedUser",
            "source" : "system/xmlfile/account",
            "target" : "managed/user",
            "taskThreads" : 20
            ...
         }
    ]
}</programlisting>

    <para>A value of <literal>0</literal> specifies that reconciliation is run
    on the main reconciliation thread, that is, in a serial manner.</para>

   </section>

 </section>

 <section xml:id="correlation">
  <title>Correlating Existing Target Objects</title>
  <indexterm>
   <primary>Synchronization</primary>
   <secondary>Correlation query</secondary>
  </indexterm>
  <indexterm>
   <primary>Synchronization</primary>
   <secondary>Correlation script</secondary>
  </indexterm>
  <indexterm>
   <primary>Correlation query</primary>
  </indexterm>
  <indexterm>
   <primary>Correlation script</primary>
  </indexterm>

  <para>
   When OpenIDM creates an object through synchronization, it creates a
   <emphasis>link</emphasis> between the source and target objects. OpenIDM
   then uses the link to determine the object's situation during later
   synchronization operations.
  </para>

  <para>
   Initial, full synchronization operations can involve correlating many
   objects on both source and target systems. You can use correlation to return
   <emphasis>matching</emphasis> record IDs with either a
   <literal>correlation query</literal> or a <literal>correlation script</literal>.
  </para>

  <para>
   With a correlation query, you can set up a query definition (_queryId,
   _queryFilter, _queryExpression), possibly with the help of a
   <literal>linkQualifier.</literal> OpenIDM executes that query
   to search through a target repository for record IDs.
  </para>

  <para>
   With a correlation script, you return a list of target record IDs. This
   script makes use of the "source" object, and possibly the value of a
   <literal>linkQualifier</literal> to find those matching record IDs.
   There is no restriction imposed on the method for finding these ID values.
   Be aware, such scripts may be relatively complex.
  </para>

  <!--
  Include when a correlationScript is ready:

  "As you can see in the following section:
   <xref linkend="correlation-scripts" />,

    which makes this option very powerful; however, as you can see in the
    following section: .... these types of scripts are relatively complex.
"
  -->

  <para>
   You can configure correlation queries and correlation scripts from the Admin
   UI. To do so, navigate to <literal>https://localhost:8443/admin</literal>
   and click Configure &gt; Mappings. Select a Mapping and then click
   Association &gt; Association Rules.
  </para>

  <para>
   See the following sections for guidance on what you would include in a
   correlation query and a correlation script, in the UI and in the
   <filename>sync.json</filename> configuration file.
  </para>

  <section xml:id="correlation-queries-overview">
   <title>Correlation Queries, in Detail</title>
   <para>
    OpenIDM processes a correlation query by constructing a query map. The
    content of the query is generated dynamically, using values from
    the source object. Each source object results in a new query being sent
    to the target system, using (possibly transformed) values from the source
    object for its execution.
   </para>

   <section xml:id="correlation-queries-configuring">
    <title>Adding Correlation Queries to a Mapping</title>

    <para>
     Correlation queries are defined as part of the mapping objects that are
     configured in the <filename>conf/sync.json</filename> file. They are run
     against <emphasis>target resources</emphasis>, either managed or system
     objects, depending on the mapping. Correlation queries on system objects
     access the connector, which executes the query on the external resource.
    </para>
    <para>
     The preferred syntax for a correlation query is a filtered query, using the
     <literal>_queryFilter</literal> keyword. Filtered queries should work in the
     same way on any backend, whereas other query types are generally specific to
     the targeted backend. Predefined queries (using <literal>_queryId</literal>)
     and native queries (using <literal>_queryExpression</literal>) can also be
     used for correlation queries. Note, however, that <literal>system</literal>
     objects do not support predefined queries, other than
     <literal>query-all-ids</literal>, which serves no purpose in a correlation
     query.
    </para>
    <para>
     To configure a correlation query, define a script whose source returns a
     query that uses the <literal>_queryFilter</literal>,
     <literal>_queryId</literal>, or <literal>_queryExpression</literal> keyword.
     For example:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       For a <literal>_queryId</literal>, the value is the named query. There
       are also named parameters in the query map are expected by that query.
      </para>
      <programlisting language="javascript">
{'_queryId' : 'for-userName', 'uid' : source.name}</programlisting>
     </listitem>
     <listitem>
      <para>
       For a <literal>_queryFilter</literal>, the value is the abstract filter
       string:
      </para>
      <programlisting language="javascript">
{ "_queryFilter" : "uid eq \"" + source.userName + "\"" }</programlisting>
     </listitem>
     <listitem>
      <para>
       For a <literal>_queryExpression</literal>, the value is the
       system-specific query expression, such as raw SQL.
      </para>
      <programlisting>
{'_queryExpression': 'select * from managed_user where givenName = \"' + source.firstname + '\"' }</programlisting>
     </listitem>
    </itemizedlist>
    <para>
     A sample correlation query definition, inside a mapping object, follows:
    </para>
    <programlisting>{
    "mappings" : [
        {
            "name" : "managedUser_systemHrdb",
            "source" : "managed/user",
            "target" : "system/scriptedsql/account",
            "links" : "systemHrdb_managedUser",
            "correlationQuery" : {
                "type" : "text/javascript",
                "source" : "var qry = {'_queryFilter': 'uid eq \"' + source.userName + '\"'}; qry"
            },
...</programlisting>

    <section xml:id="correlation-filtered-queries">
     <title>Using Filtered Queries to Correlate Objects</title>

     <para>
      For filtered queries, the script that is defined or referenced in the
      <literal>correlationQuery</literal> property must return an object with the
      following elements:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        The element that is being compared, on the target object, for example,
        <literal>uid</literal>.
       </para>
       <para>
        The element on the target object is not necessarily a single attribute.
        Your query filter can be simple or complex; valid query filters range
        from a single operator to an entire boolean expression tree.
       </para>
       <para>
        If the target object is a system object, this attribute must be referred
        to by its OpenIDM name, rather than its OpenICF
        <literal>nativeName</literal>. For example, given the following
        provisioner configuration excerpt, the name to use in the correlation
        query would be <literal>uid</literal> and not <literal>__NAME__</literal>:
       </para>
       <programlisting language="javascript">"uid" : {
    "type" : "string",
    "nativeName" : "__NAME__",
    "required" : true,
    "nativeType" : "string"
}
...    </programlisting>
      </listitem>
      <listitem>
       <para>
        The value to search for in the query.
       </para>
       <para>
        This value is generally based on one or more values from the source
        object. However, it does not have to match the value of a single source
        object property. You can define how your script uses the values from the
        source object to find a matching record in the target system.
       </para>
       <para>
        You might use a transformation of a source object property, such as
        <literal>toUpperCase()</literal>. You can concatenate that output with
        other strings or properties. You can also use this value to call an
        external REST endpoint, and redirect the response to the final
        "value" portion of the query.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      The following query finds objects on the target whose <literal>uid</literal>
      is the same as the <literal>userName</literal> of a source object.
     </para>
     <programlisting language="javascript">"correlationQuery" : {
     "type" : "text/javascript",
     "source" : "var qry = {'_queryFilter': 'uid eq \"' + source.userName + '\"'}; qry"
},   </programlisting>
     <para>
      The query filter can be simple or complex; valid query filters range
      from a single operator to an entire boolean expression tree.
     </para>
     <para>
      The query can return zero or more objects. The situation that OpenIDM
      assigns to the source object depends on the number of target objects that
      are returned. For more information, see <xref linkend="sync-situations" />.
     </para>

    </section>

    <section xml:id="correlation-predefined-queries">
     <title>Using Predefined Queries to Correlate Objects</title>

     <para>
      If you configure correlation queries with predefined queries, they must
      be defined in the configuration file for the repository, either
      <filename>openidm/conf/repo.jdbc.json</filename> or
      <filename>openidm/conf/repo.orientdb.json</filename> In addition, these
      predefined queries must also be referenced in the mapping file:
      <literal>sync.json</literal>.
     </para>
     <para>
      The following example shows a query, defined in the OrientDB repository
      configuration (<filename>openidm/conf/repo.orientdb.json</filename>), that
      can be used as the basis for a correlation query.
     </para>
     <programlisting language="javascript">"for-userName" : "SELECT * FROM ${unquoted:_resource} WHERE userName = ${uid} SKIP ${unquoted:_pagedResultsOffset} LIMIT ${unquoted:_pageSize}"
     </programlisting>
     <para>
      By default, a <literal>${value}</literal> token replacement is assumed to be
      a quoted string. If the value is not a quoted string, use the
      <literal>unquoted:</literal> prefix, as shown above.
     </para>
     <para>
      You would call this query in the mapping (<literal>sync.json</literal>) file
      as follows:
     </para>
     <programlisting language="javascript">{
    "correlationQuery": {
      "type": "text/javascript",
      "source":
        "var qry = {'_queryId' : 'for-userName', 'uid' : source.name}; qry;"
    }
  }  </programlisting>
     <para>
      In this correlation query, the <literal>_queryId</literal> property
      value (<literal>for-userName</literal>) matches the name of the query
      specified in <filename>openidm/conf/repo.orientdb.json</filename>. The
      <literal>source.name</literal> value replaces <literal>${uid}</literal> in
      the query. OpenIDM replaces <literal>${unquoted:_resource}</literal> in
      the query with the name of the table that holds managed objects.
     </para>
    </section>

    <section xml:id="correlation-expression-builder">
     <title>Using the Expression Builder to Create Correlation Queries</title>

     <para>
      OpenIDM ${docTargetVersion} provides a declarative correlation option,
      named the expression builder, that makes it easier to configure
      correlation queries.
     </para>
     <para>
      The easiest way to use the expression builder to create a correlation
      query is through the Admin UI. To access the Expression Builder, navigate
      to the desired mapping, select Association Rules, and then change the No
      Correlation Query option to Correlation Queries.
     </para>
     <mediaobject>
      <alt>Admin UI mapping screen, Association Rules</alt>
      <imageobject>
       <imagedata fileref="images/association-rules.png" format="PNG"/>
      </imageobject>
     </mediaobject>

     <para>
      Now click Add Correlation query. In the pop-up window that appears, select
      a link qualifier. (For more information, see
      <xref linkend="link-qualifier-conditions" />). You can now create your
      expression.
     </para>
     <para>
      The following image shows how you can use the expression builder to build
      a correlation query for a mapping from
      <literal>system/ldap/accounts</literal> to <literal>managed/user</literal>
      objects. The query essentially states, in order for a match to exist
      between the source (LDAP) object and the target (managed) object, both the
      <literal>givenName</literal> and <literal>telephoneNumber</literal> of those
      objects must match.
     </para>
     <mediaobject>
      <alt>Admin UI mapping screen showing correlation query</alt>
      <imageobject>
       <imagedata fileref="images/expression-builder.png" format="PNG"/>
      </imageobject>
     </mediaobject>

     <para>
      Click Submit to exit the Correlation Query pop-up window. After creating
      the Correlation Queries that you need, click Save
     </para>
     <para>
      The resulting correlation query, in the mapping configuration
      (<literal>sync.json</literal>) is as follows:
     </para>

     <programlisting language="javascript">"correlationQuery" : {
     "linkQualifier" : "user",
     "expressionTree" : {
         "all" : [
             "givenName",
             "telephoneNumber"
         ]
     },
     "mapping" : "systemLdapAccounts_managedUser",
     "type" : "text/javascript",
     "file" : "ui/correlateTreeToQueryFilter.js"
},   </programlisting>

    <para>
     You can find the logic in the expression builder in the following script:
     <filename>openidm/bin/defaults/script/ui/correlateTreeToQueryFilter.js</filename>.
     It converts the expression into the required query filter.
    </para>
   </section>
  </section>

  <section xml:id="correlating-multiple-targets">
   <title>Correlating Multiple Target Objects</title>
   <para>
    To correlate a single source entry with multiple target entries, you
    indicate how the source entry should be linked to the target entries, by
    providing correlation logic appropriate for each link qualifier.
   </para>
   <para>
    When complete, you will have created a separate correlation query for each
    mapping from a single source object to a potential target object. You can
    differentiate these correlation queries, by link, with a
    <literal>link qualifier</literal>.
   </para>
   <para>
    In the following example, the correlation query might be constructed as
    follows.
   </para>
   <programlisting>"correlationQuery" : [
    {
        "linkQualifier" : "user",
        "type" : "text/javascript",
        "source" : "var map = {'_queryFilter': 'uid eq \"' + source.userName + '\"'}; map;"
    },
    {
        "linkQualifier" : "test",
        "type" : "text/javascript",
        "source" : "var map = {'_queryFilter': 'uid eq \"' + source.userName + '-test\"'}; map;"
    }
]  </programlisting>
   <para>
    The link qualifier is assigned to the link, during correlation. In this
    example, if the <literal>uid</literal> of the target object matches the
    <literal>userName</literal> of the source object, a link with the qualifier
    <literal>user</literal> is created between the source and target object. If
    the <literal>uid</literal> of the target object matches the
    <literal>userName</literal> of the source object, and is appended with
    <literal>-test</literal>, a link with the qualifier <literal>test</literal>
    is created between the source and target object.
   </para>
  </section>

  </section>

  <section xml:id="correlation-scripts">
   <title>Correlation Scripts</title>

   <para>
    One alternative to correlation queries is a correlation script. You can
    configure a correlation script as part of a mapping in the
    <filename>sync.json</filename> file.
   </para>

   <para>
    In the following example excerpt, the <filename>correlateScript.js</filename>
    script is used to return IDs from the target repository:
   </para>

   <programlisting language="javascript">{
    "mappings" : [
        "name" : "managedUser_systemLdapAccounts",
        "source" : "managed/user"
        "target" : "system/ldap/account",
        "correlationScript" : {
            "type" : "text/javascript",
            "file" : "script/correlateScript.js"
        },
        ... </programlisting>

   <para>
    You can create a correlation script in the Admin UI. To access this feature,
    navigate to the desired mapping, select Association Rules, and then change
    the No Correlation Query option to Correlation Script.
   </para>

   <mediaobject>
    <alt>Admin UI mapping screen showing correlation script</alt>
    <imageobject>
     <imagedata fileref="images/admin-ui-corr-script.png" format="PNG"/>
    </imageobject>
   </mediaobject>

   <para>
    To create a correlation script, you should use the details from the source
    object to find the matching record in the target system. If you are using
    link qualifiers to match a single source record to multiple target records,
    then you should also use the value of the <literal>linkQualifier</literal>
    variable within your correlation script to find the target id that applies
    for that qualifier.
   </para>

   <!-- Jake recommends removing. TODO substitute a "real"
    correlationScript.js when available
   <para>
    The following is one example of
    how you might implement such a script, using the results from a
    <literal>linkQualifier</literal>.
   </para>

   <programlisting language="javascript">"correlationScript": {
    "type":"text/javascript",
    "source": "

    var ids = [];

    switch (linkQualifier) {
       case "test":
          ids = openidm.query('system/ldap/account', {
                '_queryFilter': '/uid eq \"' + source.userName + '.test\"'
                }).results.map(function (r) { return r.uid; }
    );
    break;
       case "admin":
          ids = openidm.query('system/ldap/account', {
                '_queryFilter': '/uid eq \"' + source.userName + '.test\"'
                }).results.map(function (r) { return r.uid; }
    );
    break;
       case "readonly":
          ids = openidm.query('system/ldap/account', {
                '_queryFilter': '/uid eq \"' + source.userName + '\"
                AND /isReadOnly eq true'}).results.map(function (r) { return r.uid; }
    );
    break;
    }
    if (['test','admin','readonly'].indexOf(linkQualifier)) {
      ids.concat(openidm.query('system/ldap/account', {
            '_queryFilter': '/uid eq \"' + source.userName + '\"'
            }).results.map(function (r) { return r.uid; })
    );
}

ids;
"
   </programlisting>

   <para>

   The logic uses the source and linkQualifier variables together to find
   the target system IDs that are appropriate for their respective values.
     </para>
                                       -->
  </section>

 </section>

 <section xml:id="advanced-dataflow">
  <title>Advanced Data Flow Configuration</title>
  <indexterm>
   <primary>Mappings</primary>
   <secondary>Hooks for scripting</secondary>
  </indexterm>

  <para><xref linkend="basic-sync"/> shows how to trigger scripts when objects
  are created and updated. Other situations require you to trigger scripts
  in response to other synchronization actions. For example, you might not
  want OpenIDM to delete a managed user directly when an external account record
  is deleted, but instead unlink the objects and deactivate the user in another
  resource. (Alternatively, you might delete the object in OpenIDM but
  nevertheless execute a script.) The following example shows a more advanced
  mapping configuration.</para>

<programlisting linenumbering="numbered" language="javascript">{
    "mappings": [
        {
            "name": "systemLdapAccount_managedUser",
            "source": "system/ldap/account",
            "target": "managed/user",
            "validSource": {
                "type": "text/javascript",
                "file": "script/isValid.js"
            },
            "correlationQuery" : {
                "type" : "text/javascript",
                "source" : "var map = {'_queryFilter': 'uid eq \"' +
                     source.userName + '\"'}; map;"
            },
            "properties": [
                {
                    "source": "uid",
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.toLowerCase()"
                    },
                    "target": "userName"
                },
                {
                    "source": "",
                    "transform": {
                        "type": "text/javascript",
                        "source": "if (source.myGivenName)
                            {source.myGivenName;} else {source.givenName;}"
                    },
                    "target": "givenName"
                },
                {
                    "source": "",
                    "transform": {
                        "type": "text/javascript",
                        "source": "if (source.mySn)
                            {source.mySn;} else {source.sn;}"
                    },
                    "target": "familyName"
                },
                {
                    "source": "cn",
                    "target": "fullname"
                },
                {
                    "comment": "Multi-valued in LDAP, single-valued in AD.
                        Retrieve first non-empty value.",
                    "source": "title",
                    "transform": {
                        "type": "text/javascript",
                        "file": "script/getFirstNonEmpty.js"
                    },
                    "target": "title"
                },
                {
                    "condition": {
                        "type": "text/javascript",
                        "source": "var clearObj = openidm.decrypt(object);
                            ((clearObj.password != null) &amp;&amp;
                            (clearObj.ldapPassword != clearObj.password))"
                    },
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.password"
                    },
                    "target": "__PASSWORD__"
                }
            ],
            "onCreate": {
                "type": "text/javascript",
                "source": "target.ldapPassword = null;
                    target.adPassword = null;
                    target.password = null;
                    target.ldapStatus = 'New Account'"
            },
            "onUpdate": {
                "type": "text/javascript",
                "source": "target.ldapStatus = 'OLD'"
            },
            "onUnlink": {
                "type": "text/javascript",
                "file": "script/triggerAdDisable.js"
            },
            "policies": [
                {
                    "situation": "CONFIRMED",
                    "action": "UPDATE"
                },
                {
                    "situation": "FOUND",
                    "action": "UPDATE"
                },
                {
                    "situation": "ABSENT",
                    "action": "CREATE"
                },
                {
                    "situation": "AMBIGUOUS",
                    "action": "EXCEPTION"
                },
                {
                    "situation": "MISSING",
                    "action": "EXCEPTION"
                },
                {
                    "situation": "UNQUALIFIED",
                    "action": "UNLINK"
                },
                {
                    "situation": "UNASSIGNED",
                    "action": "EXCEPTION"
                }
            ]
        }
    ]
}</programlisting>

  <variablelist>
   <para>
    The following list shows the properties that you can use as hooks in mapping
    configurations to call scripts.
   </para>
   <varlistentry>
    <term>Triggered by Situation</term>
    <!-- All related to the "Supported script hooks" section of
    ManagedObjectSet.java -->
    <listitem>
     <para>
      onCreate, onUpdate, onDelete, onLink, onUnlink
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Object Filter</term>
    <listitem>
     <para>vaildSource, validTarget</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Correlating Objects</term>
    <listitem>
     <para>correlationQuery</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Triggered on Reconciliation</term>
    <listitem>
     <para>result</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Scripts Inside Properties</term>
    <listitem>
     <para>condition, transform</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>Your scripts can get data from any connected system at any time by
  using the <literal>openidm.read(id)</literal> function, where
  <literal>id</literal> is the identifier of the object to read.</para>

  <para>The following example reads a managed user object from the
  repository.</para>

  <programlisting language="javascript">
repoUser = openidm.read("managed/user/ddoe");</programlisting>

  <para>The following example reads an account from an external LDAP
  resource.</para>

  <programlisting language="javascript">
externalAccount = openidm.read("system/ldap/account/uid=ddoe,ou=People,dc=example,dc=com");</programlisting>
  <para>Note that the query targets a DN rather than a UID, as it did in the
  previous example. The attribute that is used for the <literal>_id</literal>
  is defined in the connector configuration file and, in this example, is set
  to <literal>"uidAttribute" : "dn"</literal>. Although it is possible to use
  a DN (or any unique attribute) for the <literal>_id</literal>, as a best
  practice, you should use an attribute that is both unique and immutable.
  </para>
 </section>

 <section xml:id="scheduling-synchronization">
 <title>Scheduling Synchronization</title>
 <indexterm>
  <primary>Scheduler</primary>
 </indexterm>
 <indexterm>
  <primary>Reconciliation</primary>
  <secondary>Scheduling</secondary>
 </indexterm>
 <indexterm>
  <primary>Synchronization</primary>
  <secondary>Scheduling</secondary>
 </indexterm>
 <indexterm>
  <primary>LiveSync</primary>
  <secondary>Scheduling</secondary>
 </indexterm>

  <para>You can schedule synchronization operations, such as LiveSync and
  reconciliation, using <command>cron</command>-like syntax.</para>

  <para>This section describes scheduling for reconciliation and LiveSync,
  however, you can also use OpenIDM's scheduler service to schedule any other
  event by supplying a link to a script file, in which that event is defined.
  For information about scheduling other events, and for a deeper understanding
  of the OpenIDM scheduler service, see
  <link xlink:href="integrators-guide#chap-scheduler-conf"
  xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Scheduling Tasks
  and Events</citetitle></link>.</para>

  <section xml:id="configuring-sync-schedule">
   <title>Configuring Scheduled Synchronization</title>
   <para>
    Each scheduled reconciliation and LiveSync task requires a schedule
    configuration file in <filename>openidm/conf</filename>. By convention,
    files are named
    <filename>openidm/conf/schedule-<replaceable>schedule-name</replaceable>.json</filename>,
    where <replaceable>schedule-name</replaceable> is a
    logical name for the scheduled synchronization operation, such as
    <literal>reconcile_systemXmlAccounts_managedUser</literal>.
   </para>
   <para>
    Schedule configuration files have the following format:
   </para>
   <programlisting language="javascript">
{
 "enabled"       : true,
 "persisted"     : false,
 "type"          : "cron",
 "startTime"     : "<replaceable>(optional) time</replaceable>",
 "endTime"       : "<replaceable>(optional) time</replaceable>",
 "schedule"      : "<replaceable>cron expression</replaceable>",
 "misfirePolicy" : "<replaceable>optional, string</replaceable>",
 "timeZone"      : "<replaceable>(optional) time zone</replaceable>",
 "invokeService" : "<replaceable>service identifier</replaceable>",
 "invokeContext" : "<replaceable>service specific context info</replaceable>"
}
   </programlisting>
   <para>
    For an explanation of each of these properties, see
    <link xlink:href="integrators-guide#chap-scheduler-conf"
    xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Scheduling Tasks
    and Events</citetitle></link>.
   </para>
   <para>
    To schedule a reconciliation or LiveSync task, set the
    <literal>invokeService</literal> property to either
    <literal>"sync"</literal> (for reconciliation) or
    <literal>"provisioner"</literal> for LiveSync.
   </para>
   <para>
    The value of the <literal>invokeContext</literal> property depends on the
    type of scheduled event. For reconciliation, the properties are set as
    follows:
   </para>
   <programlisting language="javascript">
{
    "invokeService": "sync",
    "invokeContext": {
        "action": "reconcile",
        "mapping": "systemLdapAccount_managedUser"
    }
}
   </programlisting>
   <para>
    The <literal>"mapping"</literal> is either referenced by its name in the
    <filename>openidm/conf/sync.json</filename> file, or defined inline by using
    the <literal>"mapping"</literal> property, as shown in the example in
    <link xlink:href="integrators-guide#alternative-mapping"
    xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Alternative
    Mappings</citetitle></link>.
   </para>
   <para>
    For LiveSync, the properties are set as follows:
   </para>
   <programlisting language="javascript">
{
    "invokeService": "provisioner",
    "invokeContext": {
        "action": "liveSync",
        "source": "system/OpenDJ/__ACCOUNT__"
    }
}
   </programlisting>
   <para>
    The <literal>"source"</literal> property follows OpenIDM's convention for a
    pointer to an external resource object and takes the form
    <literal>system/<replaceable>resource-name/object-type</replaceable></literal>.
   </para>
  </section>

  <section xml:id="alternative-mapping">
   <title>Alternative Mappings</title>
   <indexterm>
    <primary>Mappings</primary>
    <secondary>Scheduled reconciliation</secondary>
   </indexterm>
   <para>
    Mappings for synchronization are usually stored in
    <filename>openidm/conf/sync.json</filename> for reconciliation, LiveSync,
    and for pushing changes made to managed objects to external resources. You
    can, however, provide alternative mappings for scheduled reconciliation by
    adding the mapping to the schedule configuration instead of referencing a
    mapping in <filename>sync.json</filename>.
   </para>
   <programlisting language="javascript">
{
    "enabled": true,
    "type": "cron",
    "schedule": "0 08 16 * * ?",
    "invokeService": "sync",
    "invokeContext": {
        "action": "reconcile",
        <emphasis role="bold">"mapping": {
            "name": "CSV_XML",
            "source": "system/Ldap/account",
            "target": "managed/user",
            "properties": [
                {
                    "source": "firstname",
                    "target": "firstname"
                },
                ...
            ],
            "policies": [...]
        }</emphasis>
    }
}
   </programlisting>
  </section>

 </section>
</chapter>
